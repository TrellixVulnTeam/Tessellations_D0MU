import { DEFAULT, defmulti } from "@thi.ng/defmulti/defmulti";
import { clamp01 } from "@thi.ng/math/interval";
import { fract } from "@thi.ng/math/prec";
import { SYSTEM } from "@thi.ng/random/system";
import { setC4 } from "@thi.ng/vectors/setc";
import { __ensureAlpha } from "./internal/ensure.js";
/** @internal */
const analogU = (x, delta, rnd) => delta !== 0 ? x + rnd.norm(delta) : x;
/** @internal */
const analogN = (x, delta, rnd, post = clamp01) => delta !== 0 ? post(x + rnd.norm(delta)) : x;
/** @internal */
const analogH = (x, delta, rnd) => analogN(x, delta, rnd, fract);
/** @internal */
const analogA = (a, delta, rnd) => delta !== 0
    ? clamp01((a !== undefined ? a : 1) + rnd.norm(delta))
    : __ensureAlpha(a);
export const defAnalog = (x, y, z) => (out, src, delta, rnd = SYSTEM) => setC4(out || src, x(src[0], delta, rnd), y(src[1], delta, rnd), z(src[2], delta, rnd), __ensureAlpha(src[3]));
/** @internal */
const analogHNN = defAnalog(analogH, analogN, analogN);
/** @internal */
const analogNNN = defAnalog(analogN, analogN, analogN);
/** @internal */
const analogNUU = defAnalog(analogN, analogU, analogU);
/**
 * Returns a random analog color based on given `src` color and variance
 * `delta`. Each channel will be randomized by +/- `delta`, optionally using
 * provided {@link @thi.ng/random#IRandom} PRNG.
 */
export const analog = defmulti((_, src) => src.mode, {}, {
    hcy: analogHNN,
    hsi: analogHNN,
    hsl: analogHNN,
    hsv: analogHNN,
    lab50: analogNUU,
    lab65: analogNUU,
    lch: defAnalog(analogN, analogN, analogH),
    ycc: analogNUU,
    [DEFAULT]: analogNNN,
});
/**
 * Similar to {@link analogRGB}. Returns an analog color based on given HSVA
 * color, with each channel randomly varied by given channel-specific delta
 * amounts (and optionally given {@link @thi.ng/random#IRandom} PRNG).
 *
 * @remarks
 * This function provides more user control than {@link analog}, but the latter
 * is recommended for most use cases.
 *
 * By default (unless `deltaS`, `deltaV`, `deltaA` are provided) only the hue of
 * the color will be modulated.
 *
 * @param out
 * @param src
 * @param deltaH
 * @param deltaS
 * @param deltaV
 * @param deltaA
 * @param rnd
 */
export const analogHsv = (out, src, deltaH, deltaS = 0, deltaV = 0, deltaA = 0, rnd = SYSTEM) => setC4(out || src, analogN(src[0], deltaH, rnd, fract), analogN(src[1], deltaS, rnd), analogN(src[2], deltaV, rnd), analogA(src[3], deltaA, rnd));
/**
 * Similar to {@link analogHSV}. Returns an analog color based on given RGBA
 * color, with each channel randomly varied by given delta amounts (and
 * optionally given {@link @thi.ng/random#IRandom} PRNG).
 *
 * @remarks
 * By default the green and blue channel variance will be the same as `deltaR`.
 *
 * @param out
 * @param src
 * @param deltaR
 * @param deltaG
 * @param deltaB
 * @param deltaA
 * @param rnd
 */
export const analogRgb = (out, src, deltaR, deltaG = deltaR, deltaB = deltaR, deltaA = 0, rnd = SYSTEM) => setC4(out || src, analogN(src[0], deltaR, rnd), analogN(src[1], deltaG, rnd), analogN(src[2], deltaB, rnd), analogA(src[3], deltaA, rnd));

import { implementsFunction } from "@thi.ng/checks/implements-function";
import { isArrayLike } from "@thi.ng/checks/is-arraylike";
import { isNumber } from "@thi.ng/checks/is-number";
import { isString } from "@thi.ng/checks/is-string";
import { illegalArgs } from "@thi.ng/errors/illegal-arguments";
import { EPS } from "@thi.ng/math/api";
import { vector } from "@thi.ng/strings/vector";
import { mapStridedBuffer } from "@thi.ng/vectors/buffer";
import { clamp4 } from "@thi.ng/vectors/clamp";
import { declareIndices } from "@thi.ng/vectors/compile/accessors";
import { eqDelta4 } from "@thi.ng/vectors/eqdelta";
import { stridedValues } from "@thi.ng/vectors/iterator";
import { randMinMax } from "@thi.ng/vectors/random";
import { set4 } from "@thi.ng/vectors/set";
import { convert, defConversions } from "./convert.js";
import { parseCss } from "./css/parse-css.js";
import { intArgb32Rgb } from "./int/int-rgb.js";
import { __ensureArgs } from "./internal/ensure.js";
export const defColor = (spec) => {
    const channels = spec.channels || {};
    const order = spec.order;
    const numChannels = order.length;
    order.reduce((acc, id) => {
        acc[id] = {
            range: [0, 1],
            ...channels[id],
        };
        return acc;
    }, channels);
    const min = order.map((id) => channels[id].range[0]);
    const max = order.map((id) => channels[id].range[1]);
    // fix alpha channel for randomize()
    const minR = set4([], min);
    const maxR = set4([], max);
    minR[numChannels - 1] = 1;
    const $Color = class {
        constructor(buf, offset = 0, stride = 1) {
            this.offset = offset;
            this.stride = stride;
            this.buf = buf || [0, 0, 0, 0];
            this.offset = offset;
            this.stride = stride;
        }
        get mode() {
            return spec.mode;
        }
        get length() {
            return numChannels;
        }
        get range() {
            return [min, max];
        }
        get [Symbol.toStringTag]() {
            return spec.mode;
        }
        [Symbol.iterator]() {
            return stridedValues(this.buf, this.length, this.offset, this.stride);
        }
        copy() {
            return new $Color(this.deref());
        }
        copyView() {
            return new $Color(this.buf, this.offset, this.stride);
        }
        empty() {
            return new $Color();
        }
        deref() {
            return [this[0], this[1], this[2], this[3]];
        }
        set(src) {
            return set4(this, src);
        }
        clamp() {
            return clamp4(null, this, min, max);
        }
        eqDelta(o, eps = EPS) {
            return eqDelta4(this, o, eps);
        }
        randomize(rnd) {
            return randMinMax(this, minR, maxR, rnd);
        }
        toJSON() {
            return this.deref();
        }
        toString() {
            return vector(4, 4)(this);
        }
    };
    declareIndices($Color.prototype, order);
    defConversions(spec.mode, spec.from);
    defConversions("rgb", { [spec.mode]: spec.toRgb });
    const fromColor = (src, mode, xs) => {
        const res = new $Color(...xs);
        return mode !== spec.mode
            ? convert(res, src, spec.mode, mode)
            : res.set(src);
    };
    const factory = (src, ...xs) => src == null
        ? new $Color()
        : isString(src)
            ? factory(parseCss(src), ...xs)
            : isArrayLike(src)
                ? isString(src.mode)
                    ? fromColor(src, src.mode, xs)
                    : new $Color(src, ...xs)
                : implementsFunction(src, "deref")
                    ? fromColor(src.deref(), src.mode, xs)
                    : isNumber(src)
                        ? xs.length && xs.every(isNumber)
                            ? new $Color(...__ensureArgs([src, ...xs]))
                            : fromColor(intArgb32Rgb([], src), "rgb", xs)
                        : illegalArgs(`can't create a ${spec.mode} color from: ${src}`);
    factory.class = $Color;
    factory.range = [min, max];
    factory.random = (rnd, buf, idx, stride) => new $Color(buf, idx, stride).randomize(rnd);
    factory.mapBuffer = (buf, num = (buf.length / numChannels) | 0, start = 0, cstride = 1, estride = numChannels) => mapStridedBuffer($Color, buf, num, start, cstride, estride);
    return factory;
};

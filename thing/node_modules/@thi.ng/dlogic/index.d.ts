import type { FnU2, FnU3, FnU4 } from "@thi.ng/api";
declare type Op2 = FnU2<boolean>;
declare type Op3 = FnU3<boolean>;
declare type Op4 = FnU4<boolean>;
export interface Sum<T> {
    s: T;
    c: boolean;
}
/**
 * {@link https://en.wikipedia.org/wiki/Inverter_(logic_gate)}
 *
 * | X | Q |
 * |---|---|
 * | 0 | 1 |
 * | 1 | 0 |
 *
 * @param x -
 */
export declare const not: (x: boolean) => boolean;
/**
 * {@link https://en.wikipedia.org/wiki/NAND_gate}
 *
 * | A | B | Q |
 * |---|---|---|
 * | 0 | 0 | 1 |
 * | 0 | 1 | 1 |
 * | 1 | 0 | 1 |
 * | 1 | 1 | 0 |
 *
 * @param a -
 * @param b -
 */
export declare const nand: Op2;
/**
 * {@link https://en.wikipedia.org/wiki/AND_gate}
 *
 * | A | B | Q |
 * |---|---|---|
 * | 0 | 0 | 0 |
 * | 0 | 1 | 0 |
 * | 1 | 0 | 0 |
 * | 1 | 1 | 1 |
 *
 * @param a -
 * @param b -
 */
export declare const and: Op2;
/**
 * {@link https://en.wikipedia.org/wiki/OR_gate}
 *
 * | A | B | Q |
 * |---|---|---|
 * | 0 | 0 | 0 |
 * | 0 | 1 | 1 |
 * | 1 | 0 | 1 |
 * | 1 | 1 | 1 |
 *
 * @param a -
 * @param b -
 */
export declare const or: Op2;
/**
 * {@link https://en.wikipedia.org/wiki/NOR_gate}
 *
 * | A | B | Q |
 * |---|---|---|
 * | 0 | 0 | 1 |
 * | 0 | 1 | 0 |
 * | 1 | 0 | 0 |
 * | 1 | 1 | 0 |
 *
 * @param a -
 * @param b -
 */
export declare const nor: Op2;
/**
 * {@link https://en.wikipedia.org/wiki/XOR_gate}
 *
 * | A | B | Q |
 * |---|---|---|
 * | 0 | 0 | 0 |
 * | 0 | 1 | 1 |
 * | 1 | 0 | 1 |
 * | 1 | 1 | 0 |
 *
 * @param a -
 * @param b -
 */
export declare const xor: Op2;
/**
 * {@link https://en.wikipedia.org/wiki/XNOR_gate}
 *
 * | A | B | Q |
 * |---|---|---|
 * | 0 | 0 | 1 |
 * | 0 | 1 | 0 |
 * | 1 | 0 | 0 |
 * | 1 | 1 | 1 |
 *
 * @param a -
 * @param b -
 */
export declare const xnor: Op2;
/**
 * {@link https://web.archive.org/web/20160304050642/http://www.zigwap.com/digital/gates/imply_gate}
 *
 * | A | B | Q |
 * |---|---|---|
 * | 0 | 0 | 1 |
 * | 0 | 1 | 1 |
 * | 1 | 0 | 0 |
 * | 1 | 1 | 1 |
 * @param a -
 * @param b -
 */
export declare const imply: Op2;
/**
 * {@link https://en.wikipedia.org/wiki/AND-OR-Invert}
 *
 * `q = nor(a, and(b, c))`
 *
 * | A | B | C | Q |
 * |---|---|---|---|
 * | 0 | 0 | 0 | 1 |
 * | 0 | 0 | 1 | 1 |
 * | 0 | 1 | 0 | 1 |
 * | 0 | 1 | 1 | 0 |
 * | 1 | 0 | 0 | 0 |
 * | 1 | 0 | 1 | 0 |
 * | 1 | 1 | 0 | 0 |
 * | 1 | 1 | 1 | 0 |
 *
 * @param a -
 * @param b -
 * @param c -
 */
export declare const aoi21: Op3;
/**
 * {@link https://en.wikipedia.org/wiki/AND-OR-Invert}
 *
 * `q = nor(and(a, b), and(c, d))`
 *
 * | A | B | C | D | Q |
 * |---|---|---|---|---|
 * | 0 | X | X | 0 | 1 |
 * | X | 0 | X | 0 | 1 |
 * | 0 | X | 0 | X | 1 |
 * | X | 0 | 0 | X | 1 |
 * | 1 | 1 | X | X | 0 |
 * | X | X | 1 | 1 | 0 |
 *
 * @param a -
 * @param b -
 * @param c -
 */
export declare const aoi22: Op4;
/**
 * Complement logic of {@link aoi21}.
 *
 * `q = nand(a, or(b, c))`
 *
 * @param a -
 * @param b -
 * @param c -
 */
export declare const oai21: Op3;
/**
 * Complement logic of {@link aoi22}.
 *
 * `q = nand(or(a, b), or(c, d))`
 *
 * @param a -
 * @param b -
 * @param c -
 * @param d -
 */
export declare const oai22: Op4;
/**
 * {@link https://en.wikipedia.org/wiki/NAND_logic#MUX}
 *
 * | A | B | S | Q |
 * |---|---|---|---|
 * | 0 | 0 | 0 | 0 |
 * | 0 | 1 | 0 | 0 |
 * | 1 | 0 | 0 | 1 |
 * | 1 | 1 | 0 | 1 |
 * | 0 | 0 | 1 | 0 |
 * | 0 | 1 | 1 | 1 |
 * | 1 | 0 | 1 | 0 |
 * | 1 | 1 | 1 | 1 |
 *
 * @param a -
 * @param b -
 * @param s -
 */
export declare const mux: Op3;
/**
 * {@link https://en.wikipedia.org/wiki/NAND_logic#DEMUX}
 *
 * | I | S | A | B |
 * |---|---|---|---|
 * | 0 | 0 | 0 | 0 |
 * | 1 | 0 | 1 | 0 |
 * | 0 | 1 | 0 | 0 |
 * | 1 | 1 | 0 | 1 |
 *
 * @param i -
 * @param s -
 */
export declare const demux: FnU2<boolean, [boolean, boolean]>;
/**
 * {@link https://en.wikipedia.org/wiki/Adder_(electronics)#Half_adder}
 *
 * @param a -
 * @param b -
 */
export declare const hadd1: FnU2<boolean, Sum<boolean>>;
/**
 * {@link https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder}
 *
 * @param a -
 * @param b -
 * @param c -
 */
export declare const fadd1: FnU3<boolean, Sum<boolean>>;
/**
 * {@link https://en.wikipedia.org/wiki/Adder_(electronics)#Ripple-carry_adder}
 *
 * @param a -
 * @param b -
 * @param c -
 */
export declare const rca: (a: boolean[], b: boolean[], c: boolean) => Sum<boolean[]>;
/**
 * HOF delay line generator. Returned function takes single boolean arg,
 * buffers `n` values (ring buffer) and returns currently oldest. The
 * first `n` results will always be `false`.
 *
 * @param n -
 */
export declare const delay: (n: number) => (x: boolean) => boolean;
export {};
//# sourceMappingURL=index.d.ts.map
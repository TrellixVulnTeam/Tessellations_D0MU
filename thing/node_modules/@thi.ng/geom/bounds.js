import { defmulti } from "@thi.ng/defmulti/defmulti";
import { bounds as arcBounds } from "@thi.ng/geom-arc/bounds";
import { bounds as _bounds } from "@thi.ng/geom-poly-utils/bounds";
import { cubicBounds } from "@thi.ng/geom-splines/cubic-bounds";
import { quadraticBounds } from "@thi.ng/geom-splines/quadratic-bounds";
import { comp } from "@thi.ng/transducers/comp";
import { filter } from "@thi.ng/transducers/filter";
import { iterator1 } from "@thi.ng/transducers/iterator";
import { map } from "@thi.ng/transducers/map";
import { MAX2, MAX3, MIN2, MIN3 } from "@thi.ng/vectors/api";
import { max } from "@thi.ng/vectors/max";
import { min } from "@thi.ng/vectors/min";
import { mul2 } from "@thi.ng/vectors/mul";
import { mulN2 } from "@thi.ng/vectors/muln";
import { set2, set3 } from "@thi.ng/vectors/set";
import { sub2 } from "@thi.ng/vectors/sub";
import { subN2 } from "@thi.ng/vectors/subn";
import { aabbFromMinMax } from "./aabb.js";
import { Rect } from "./api/rect.js";
import { __collBounds } from "./internal/bounds.js";
import { __dispatch } from "./internal/dispatch.js";
import { rectFromMinMax } from "./rect.js";
export const bounds = defmulti(__dispatch, {
    aabb: "rect",
    poly: "points",
    polyline: "points",
    quad: "points",
    tri: "points",
}, {
    arc: ($) => rectFromMinMax(...arcBounds($.pos, $.r, $.axis, $.start, $.end)),
    circle: ($) => new Rect(subN2([], $.pos, $.r), mulN2(null, [2, 2], $.r)),
    cubic: ({ points }) => rectFromMinMax(...cubicBounds(points[0], points[1], points[2], points[3])),
    ellipse: ($) => new Rect(sub2([], $.pos, $.r), mul2(null, [2, 2], $.r)),
    group: ($) => {
        const res = __collBounds($.children, bounds);
        return res ? new Rect(...res) : undefined;
    },
    line: ({ points: [a, b] }) => rectFromMinMax(min([], a, b), max([], a, b)),
    path: (path) => {
        const b = __collBounds([
            ...iterator1(comp(map((s) => s.geo), filter((s) => !!s)), path.segments),
        ], bounds);
        return b ? new Rect(...b) : undefined;
    },
    points: ($) => rectFromMinMax(..._bounds($.points, set2([], MAX2), set2([], MIN2))),
    points3: ($) => aabbFromMinMax(..._bounds($.points, set3([], MAX3), set3([], MIN3))),
    quadratic: ({ points }) => rectFromMinMax(...quadraticBounds(points[0], points[1], points[2])),
    rect: ($) => $.copy(),
    text: ($) => new Rect(set2([], $.pos), [0, 0]),
});

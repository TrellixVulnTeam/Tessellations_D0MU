import type { NumericArray, TypedArrayTypeMap } from "@thi.ng/api";
import { Type } from "@thi.ng/api/typedarray";
import type { ReadonlyVec, Vec, VecOpSV, VectorConstructor } from "./api.js";
/**
 * Takes an `ArrayBuffer` and creates a number of typed array vector
 * views of `type` with given `size` (number of elements per vector) and
 * spacing. `byteOffset` defines the start offset for the first vector
 * and `byteStride` the number of bytes between resulting vectors
 * (defaults to `size * SIZEOF[type]`). It's user's responsibility to
 * ensure these two values are compatible with the chosen array type
 * (i.e. for `"f32"`, these MUST be multiples of 4).
 *
 * @example
 * ```ts
 * mapBuffer("f32", new ArrayBuffer(32), 4, 2)
 * // [
 * //   Float32Array [ 0, 0 ],
 * //   Float32Array [ 0, 0 ],
 * //   Float32Array [ 0, 0 ],
 * //   Float32Array [ 0, 0 ]
 * // ]
 * ```
 *
 * @param type -
 * @param buf -
 * @param num -
 * @param size -
 * @param byteOffset -
 * @param byteStride -
 */
export declare const mapBuffer: <T extends Type>(type: T, buf: ArrayBufferLike, num: number, size: number, byteOffset?: number, byteStride?: number) => TypedArrayTypeMap[T][];
/**
 * Writes given `src` vector values into mapped `ArrayBuffer` of stated
 * `type` and from given offset & stride/spacing.
 *
 * {@link mapBuffer}
 *
 * @param type -
 * @param buf -
 * @param src -
 * @param byteOffset -
 * @param byteStride -
 */
export declare const intoBuffer: <T extends Type>(type: T, buf: ArrayBufferLike, src: Iterable<ReadonlyVec>, byteOffset: number, byteStride: number) => void;
export declare const mapStridedBuffer: <T>(ctor: VectorConstructor<T>, buf: NumericArray, num: number, start: number, cstride: number, estride: number) => T[];
export declare const intoStridedBuffer: (set: VecOpSV, buf: NumericArray, src: Iterable<Vec>, start: number, cstride: number, estride: number) => NumericArray;
//# sourceMappingURL=buffer.d.ts.map
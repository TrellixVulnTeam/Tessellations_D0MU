import type { ArrayLikeIterable, Fn, Fn0, Fn2, Fn3, Fn4, Fn6, Fn7, FnU2, ICopy, IEmpty, IEqualsDelta, ILength, NumericArray, Tuple, TypedArray } from "@thi.ng/api";
export interface Vec extends Iterable<number>, ILength {
    [id: number]: number;
}
export interface BVec extends Iterable<boolean>, ILength {
    [id: number]: boolean;
}
export declare type ReadonlyVec = ArrayLikeIterable<number>;
export declare type ReadonlyBVec = ArrayLikeIterable<boolean>;
export declare type Vec2Like = Tuple<number, 2> | TypedArray;
export declare type Vec3Like = Tuple<number, 3> | TypedArray;
export declare type Vec4Like = Tuple<number, 4> | TypedArray;
export declare type BVec2Like = Tuple<boolean, 2>;
export declare type BVec3Like = Tuple<boolean, 3>;
export declare type BVec4Like = Tuple<boolean, 4>;
export interface StridedVec {
    buf: NumericArray;
    offset: number;
    stride: number;
}
export interface IVector<T> extends Vec, ICopy<T>, ICopyView<T>, IEmpty<T>, IEqualsDelta<T>, StridedVec {
}
export interface ICopyView<T> {
    copyView(): T;
}
export interface VectorConstructor<T> {
    new (buf: NumericArray, offset?: number, stride?: number): T;
}
export interface MultiVecOp<VOP> {
    /**
     * Adds / overwrites implementation for given vector size.
     *
     * @param dim -
     * @param op -
     */
    add(dim: number, op: VOP): VOP;
    /**
     * Adds / overwrites default implementation (SHOULD support
     * arbitrary vector sizes).
     *
     * @param op -
     */
    default(op: VOP): VOP;
    /**
     * Returns implementation for given vector size or default
     * implementation.
     *
     * @param dim -
     */
    impl(dim: number): VOP;
}
export declare type VecPair = [Vec, Vec];
export declare type VecOpV = Fn2<Vec | null, ReadonlyVec, Vec>;
export declare type VecOpN = Fn2<Vec | null, number, Vec>;
export declare type VecOpVV = Fn3<Vec | null, ReadonlyVec, ReadonlyVec, Vec>;
export declare type VecOpVN = Fn3<Vec | null, ReadonlyVec, number, Vec>;
export declare type VecOpVVV = Fn4<Vec | null, ReadonlyVec, ReadonlyVec, ReadonlyVec, Vec>;
export declare type VecOpVVN = Fn4<Vec | null, ReadonlyVec, ReadonlyVec, number, Vec>;
export declare type VecOpVNV = Fn4<Vec | null, ReadonlyVec, number, ReadonlyVec, Vec>;
export declare type VecOpVNN = Fn4<Vec | null, ReadonlyVec, number, number, Vec>;
export declare type VecOpVVVVV = Fn6<Vec | null, ReadonlyVec, ReadonlyVec, ReadonlyVec, ReadonlyVec, ReadonlyVec, Vec>;
export declare type VecOpVVVVNN = Fn7<Vec | null, ReadonlyVec, ReadonlyVec, ReadonlyVec, ReadonlyVec, number, number, Vec>;
export declare type VecOpVO<T> = (out: Vec | null, a: ReadonlyVec, b?: T) => Vec;
export declare type VecOpOO<A, B> = (out: Vec | null, a?: A, b?: B) => Vec;
export declare type VecOpOOO<A, B, C> = (out: Vec | null, a?: A, b?: B, c?: C) => Vec;
export declare type VecOpNNO<T> = (out: Vec | null, a: number, b: number, c?: T) => Vec;
export declare type VecOpRoV<T> = Fn<ReadonlyVec, T>;
export declare type VecOpRoVV<T> = FnU2<ReadonlyVec, T>;
export declare type VecOpRoVVO<T, O> = (a: ReadonlyVec, b: ReadonlyVec, c?: O) => T;
export declare type VecOpFN = (out: Vec | null, fn: Fn0<number>, n?: number) => Vec;
export declare type VecOpSV = (out: Vec | null, a: ReadonlyVec, io?: number, ia?: number, so?: number, sa?: number) => Vec;
export declare type VecOpSGV = (out: Vec | null, a: ReadonlyVec, num: number, io?: number, ia?: number, so?: number, sa?: number) => Vec;
export declare type VecOpSN = (out: Vec | null, n: number, io?: number, so?: number) => Vec;
export declare type VecOpSGN = (out: Vec | null, n: number, num: number, io?: number, so?: number) => Vec;
export declare type VecOpSVN = (out: Vec | null, a: ReadonlyVec, n: number, io?: number, ia?: number, so?: number, sa?: number) => Vec;
export declare type VecOpSGVN = (out: Vec | null, a: ReadonlyVec, n: number, num: number, io?: number, ia?: number, so?: number, sa?: number) => Vec;
export declare type VecOpSVV = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSGVV = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, num: number, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSVNV = (out: Vec | null, a: ReadonlyVec, n: number, b: ReadonlyVec, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSGVNV = (out: Vec | null, a: ReadonlyVec, n: number, b: ReadonlyVec, num: number, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSVVN = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, n: number, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSGVVN = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, n: number, num: number, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSVVV = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, c: ReadonlyVec, io?: number, ia?: number, ib?: number, ic?: number, so?: number, sa?: number, sb?: number, sc?: number) => Vec;
export declare type VecOpSGVVV = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, c: ReadonlyVec, num: number, io?: number, ia?: number, ib?: number, ic?: number, so?: number, sa?: number, sb?: number, sc?: number) => Vec;
export declare type VecOpSRoV<T> = (a: ReadonlyVec, ia?: number, sa?: number) => T;
export declare type VecOpSGRoV<T> = (a: ReadonlyVec, num: number, ia?: number, sa?: number) => T;
export declare type VecOpSRoVV<T> = (a: ReadonlyVec, b: ReadonlyVec, ia?: number, ib?: number, sa?: number, sb?: number) => T;
export declare type VecOpSVO<T> = (out: Vec | null, a: ReadonlyVec, b?: T, io?: number, ia?: number, so?: number, sa?: number) => Vec;
export declare type VecOpSGVO<T> = (out: Vec | null, a: ReadonlyVec, num: number, b?: T, io?: number, ia?: number, so?: number, sa?: number) => Vec;
export declare type VecOpSOO<A, B> = (a: Vec | null, opt1?: A, opt2?: B, ia?: number, sa?: number) => Vec;
export declare type VecOpSGOO<A, B> = (a: Vec | null, num: number, opt1?: A, opt2?: B, ia?: number, sa?: number) => Vec;
export declare type VecOpSOOO<A, B, C> = (a: Vec | null, opt1?: A, opt2?: B, opt3?: C, ia?: number, sa?: number) => Vec;
export declare type VecOpSGOOO<A, B, C> = (a: Vec | null, num: number, opt1?: A, opt2?: B, opt3?: C, ia?: number, sa?: number) => Vec;
export declare type VecOpSVVO<O> = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, opt?: O, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSGVVO<O> = (out: Vec | null, a: ReadonlyVec, b: ReadonlyVec, num: number, opt?: O, io?: number, ia?: number, ib?: number, so?: number, sa?: number, sb?: number) => Vec;
export declare type VecOpSGFN = (out: Vec | null, num: number, fn: Fn0<number>, n?: number, io?: number, so?: number) => Vec;
export declare type VecOpSFN = (out: Vec | null, fn: Fn0<number>, n?: number, io?: number, so?: number) => Vec;
export declare type MultiVecOpImpl<T> = T & MultiVecOp<T>;
export declare type MultiVecOpV = MultiVecOpImpl<VecOpV>;
export declare type MultiVecOpN = MultiVecOpImpl<VecOpN>;
export declare type MultiVecOpVV = MultiVecOpImpl<VecOpVV>;
export declare type MultiVecOpVN = MultiVecOpImpl<VecOpVN>;
export declare type MultiVecOpVVV = MultiVecOpImpl<VecOpVVV>;
export declare type MultiVecOpVVN = MultiVecOpImpl<VecOpVVN>;
export declare type MultiVecOpVNV = MultiVecOpImpl<VecOpVNV>;
export declare type MultiVecOpVNN = MultiVecOpImpl<VecOpVNN>;
export declare type MultiVecOpVVVVV = MultiVecOpImpl<VecOpVVVVV>;
export declare type MultiVecOpVVVVNN = MultiVecOpImpl<VecOpVVVVNN>;
export declare type MultiVecOpVO<T> = MultiVecOpImpl<VecOpVO<T>>;
export declare type MultiVecOpOO<A, B> = MultiVecOpImpl<VecOpOO<A, B>>;
export declare type MultiVecOpOOO<A, B, C> = MultiVecOpImpl<VecOpOOO<A, B, C>>;
export declare type MultiVecOpNNO<T> = MultiVecOpImpl<VecOpNNO<T>>;
export declare type MultiVecOpRoV<T> = MultiVecOpImpl<VecOpRoV<T>>;
export declare type MultiVecOpRoVV<T> = MultiVecOpImpl<VecOpRoVV<T>>;
export declare type MultiVecOpRoVVO<T, O> = MultiVecOpImpl<VecOpRoVVO<T, O>>;
export declare type MultiVecOpFN = MultiVecOpImpl<VecOpFN>;
export declare type MultiVecOpSFN = MultiVecOpImpl<VecOpSFN>;
export declare type BVecOpRoV<T> = Fn<ReadonlyBVec, T>;
export declare type BVecOpV = Fn2<BVec | null, ReadonlyBVec, BVec>;
export declare type BVecOpVV = Fn3<BVec | null, ReadonlyBVec, ReadonlyBVec, BVec>;
export declare type BVecOpVN = Fn3<BVec | null, ReadonlyBVec, boolean, BVec>;
export declare type ToBVecOpV = Fn2<BVec | null, ReadonlyVec, BVec>;
export declare type FromBVecOpV = Fn2<BVec | null, ReadonlyBVec, Vec>;
export declare type MultiBVecOpV = MultiVecOpImpl<BVecOpV>;
export declare type MultiBVecOpVV = MultiVecOpImpl<BVecOpVV>;
export declare type MultiBVecOpVN = MultiVecOpImpl<BVecOpVN>;
export declare type MultiBVecOpRoV<T> = MultiVecOpImpl<BVecOpRoV<T>>;
export declare type MultiToBVecOpV = MultiVecOpImpl<ToBVecOpV>;
export declare type MultiFromBVecOpV = MultiVecOpImpl<FromBVecOpV>;
export declare type CompareOp = Fn3<BVec | null, ReadonlyVec, ReadonlyVec, BVec>;
export declare type MultiCompareOp = MultiVecOpImpl<CompareOp>;
export declare type DistanceFn = VecOpRoVV<number>;
export declare const MIN2: ReadonlyVec;
export declare const MAX2: ReadonlyVec;
export declare const ONE2: ReadonlyVec;
export declare const ZERO2: ReadonlyVec;
export declare const X2: ReadonlyVec;
export declare const Y2: ReadonlyVec;
export declare const MIN3: ReadonlyVec;
export declare const MAX3: ReadonlyVec;
export declare const ONE3: ReadonlyVec;
export declare const ZERO3: ReadonlyVec;
export declare const X3: ReadonlyVec;
export declare const Y3: ReadonlyVec;
export declare const Z3: ReadonlyVec;
export declare const MIN4: ReadonlyVec;
export declare const MAX4: ReadonlyVec;
export declare const ONE4: ReadonlyVec;
export declare const ZERO4: ReadonlyVec;
export declare const X4: ReadonlyVec;
export declare const Y4: ReadonlyVec;
export declare const Z4: ReadonlyVec;
export declare const W4: ReadonlyVec;
export declare type Template = (syms: string[], i?: number) => string;
export interface ToStringOpts {
    /**
     * Number of fractional digits
     *
     * @defaultValue 3
     */
    prec: number;
    /**
     * If given, each formatted vector component will be padded to given number
     * of characters.
     */
    width: number;
    /**
     * Inter-component delimiter.
     *
     * @defaultValue ", "
     */
    delim: string;
    /**
     * Prefix/suffix wrapper strings.
     *
     * @defaultValue "[" and "]"
     */
    wrap: ArrayLike<string>;
}
//# sourceMappingURL=api.d.ts.map
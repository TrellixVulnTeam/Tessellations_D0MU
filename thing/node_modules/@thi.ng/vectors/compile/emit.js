import { comp } from "@thi.ng/transducers/comp";
import { map } from "@thi.ng/transducers/map";
import { mapIndexed } from "@thi.ng/transducers/map-indexed";
import { range } from "@thi.ng/transducers/range";
import { str } from "@thi.ng/transducers/str";
import { take } from "@thi.ng/transducers/take";
import { transduce } from "@thi.ng/transducers/transduce";
import { zip } from "@thi.ng/transducers/zip";
import { vop } from "../vop.js";
import { ARGS_V, ARGS_VN, ARGS_VV, DEFAULT_OUT, FN, MATH, MATH_N, SARGS_VV, SIGNED, SIGNED_N, UNSIGNED, UNSIGNED_N, } from "./templates.js";
/**
 * HOF array index lookup gen to provide optimized versions of:
 *
 * @example
 * ```ts
 * lookup("a")(0) // a[ia]
 * lookup("a")(1) // a[ia * sa]
 * lookup("a")(2) // a[ia + 2 * sa]
 * ```
 *
 * @param sym -
 */
const lookup = (sym) => (i) => i > 1
    ? `${sym}[i${sym}+${i}*s${sym}]`
    : i == 1
        ? `${sym}[i${sym}+s${sym}]`
        : `${sym}[i${sym}]`;
/**
 * Infinite iterator of strided index lookups for `sym`.
 *
 * @param sym -
 */
const indicesStrided = (sym) => map(lookup(sym), range());
/**
 * Infinite iterator of simple (non-strided) index lookups for `sym`.
 *
 * @param sym -
 */
const indices = (sym) => map((i) => `${sym}[${i}]`, range());
/**
 * Code generator for loop-unrolled vector operations. Takes a vector
 * size `dim`, a code template function `tpl` and an array of symbol
 * names participating in the template. For each symbol, creates
 * iterator of index lookups (e.g. `a[0]` or `a[ia+k*sa]`), forms them
 * into tuples and passes them to template to generate code and joins
 * generated result with `opJoin` separator (default:
 * `""`).
 *
 * If the optional `ret` arg is not `null` (default `"a"`), appends a
 * `return` statement to the result array, using `ret` as return value.
 * Returns array of source code lines.
 *
 * The optional `pre` and `post` strings can be used to wrap the
 * generated code. `post` will be injected **before** the generated
 * return statement (if not suppressed).
 *
 * @param dim -
 * @param tpl -
 * @param syms -
 * @param ret -
 * @param opJoin -
 * @param pre -
 * @param post -
 * @param strided -
 */
const assemble = (dim, tpl, syms, ret = "a", opJoin = "", pre = "", post = "", strided = false) => [
    pre,
    transduce(comp(take(dim), mapIndexed((i, x) => tpl(x, i))), str(opJoin), (zip.apply(null, syms.split(",").map(strided ? indicesStrided : indices)))),
    post,
    ret !== "" ? `return ${ret};` : "",
];
const assembleG = (tpl, syms, ret = "a", pre, post, strided = false) => [
    pre,
    "for(let i=a.length;--i>=0;) {",
    tpl(syms
        .split(",")
        .map(strided ? (x) => `${x}[i${x}+i*s${x}]` : (x) => `${x}[i]`)),
    "}",
    post,
    ret !== null ? `return ${ret};` : "",
];
const assembleS = (tpl, syms = ARGS_VV, ret = "o", pre = DEFAULT_OUT, post) => [
    pre,
    "while(k-->0) {",
    tpl(syms.split(",").map((x) => `${x}[i${x}+k*s${x}]`)),
    "}",
    post,
    ret !== null ? `return ${ret};` : "",
];
/** @internal */
export const defaultOut = (o, args) => `!${o} && (${o}=${args.split(",")[1]});`;
/** @internal */
export const compile = (dim, tpl, args, syms = args, ret = "a", opJoin, pre, post, strided = false) => (new Function(args, assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join("")));
/** @internal */
export const compileHOF = (dim, fns, tpl, hofArgs, args, syms = args, ret = "a", opJoin = "", pre, post, strided = false) => {
    return new Function(hofArgs, `return (${args})=>{${assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join("")}}`)(...fns);
};
/** @internal */
export const compileG = (tpl, args, syms = args, ret = "a", pre, post, strided = false) => (new Function(args, assembleG(tpl, syms, ret, pre, post, strided).join("")));
/** @internal */
export const compileS = (tpl, args, syms = args, ret, pre, post) => new Function(args, assembleS(tpl, syms, ret, pre, post).join(""));
/** @internal */
export const compileGHOF = (fns, tpl, hofArgs, args, syms = args, ret = "a", pre, post, strided = false) => (new Function(hofArgs, `return (${args})=>{${assembleG(tpl, syms, ret, pre, post, strided).join("")}}`)(...fns));
export const defOp = (tpl, args = ARGS_VV, syms, ret = "o", dispatch = 1, pre) => {
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = vop(dispatch);
    const $ = (dim) => fn.add(dim, compile(dim, tpl, args, syms, ret, "", pre));
    fn.default(compileG(tpl, args, syms, ret, pre));
    return [fn, $(2), $(3), $(4)];
};
export const defFnOp = (op) => defOp(FN(op), ARGS_V);
export const defHofOp = (op, tpl, args = ARGS_V, syms, ret = "o", dispatch = 1, pre) => {
    const _tpl = tpl || FN("op");
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = vop(dispatch);
    const $ = (dim) => fn.add(dim, compileHOF(dim, [op], _tpl, "op", args, syms, ret, "", pre));
    fn.default(compileGHOF([op], _tpl, "op", args, syms, ret, pre));
    return [fn, $(2), $(3), $(4)];
};
export const defOpS = (tpl, args = ARGS_VV, idxArgs = SARGS_VV, syms = ARGS_VV, ret = "o", pre, sizes = [2, 3, 4]) => [
    compileS(tpl, `${args},k,${idxArgs}`, syms, ret, pre),
    ...sizes.map((dim) => compile(dim, tpl, `${args},${idxArgs}`, syms, ret, "", pre != null ? pre : defaultOut(ret, args), "", true)),
];
export const defHofOpS = (op, tpl, args = ARGS_VV, idxArgs = SARGS_VV, syms = ARGS_VV, ret = "o", pre, sizes = [2, 3, 4]) => [
    new Function("op", `return (${args},k,${idxArgs})=>{${assembleS(tpl, syms, ret, pre).join("")}}`)(op),
    ...sizes.map((dim) => compileHOF(dim, [op], tpl, "op", `${args},${idxArgs}`, syms, ret, "", pre != null ? pre : defaultOut(ret, args), "", true)),
];
export const defMathOp = (op) => defOp(MATH(op));
export const defMathOpN = (op) => defOp(MATH_N(op), ARGS_VN);
export const defBitOp = (op, signed = false) => defOp((signed ? SIGNED : UNSIGNED)(op));
export const defBitOpN = (op, signed = false) => defOp((signed ? SIGNED_N : UNSIGNED_N)(op), ARGS_VN);

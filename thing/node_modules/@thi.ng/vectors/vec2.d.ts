import type { IHash, NumericArray } from "@thi.ng/api";
import { IVector, ReadonlyVec, Vec } from "./api.js";
import { AVec } from "./avec.js";
export declare class Vec2 extends AVec implements IHash<number>, IVector<Vec2> {
    /**
     * Returns array of memory mapped {@link Vec2} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XY vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */
    static mapBuffer(buf: NumericArray, num?: number, start?: number, cstride?: number, estride?: number): Vec2[];
    /**
     * Merges given `src` iterable of {@link Vec2}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec2.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */
    static intoBuffer(buf: NumericArray, src: Iterable<Vec2>, start?: number, cstride?: number, estride?: number): NumericArray;
    static iterator(buf: NumericArray, num: number, start?: number, cstride?: number, estride?: number): Generator<Vec2, void, unknown>;
    static readonly X_AXIS: Vec2;
    static readonly Y_AXIS: Vec2;
    static readonly MIN: Vec2;
    static readonly MAX: Vec2;
    static readonly ZERO: Vec2;
    static readonly ONE: Vec2;
    x: number;
    y: number;
    [id: number]: number;
    constructor(buf?: NumericArray, offset?: number, stride?: number);
    [Symbol.iterator](): Generator<number, void, unknown>;
    get length(): number;
    copy(): Vec2;
    copyView(): Vec2;
    empty(): Vec2;
    eqDelta(v: ReadonlyVec, eps?: number): boolean;
    hash(): number;
    toJSON(): number[];
}
export declare const vec2: (x?: number, y?: number) => Vec2;
export declare const vec2n: (n: number) => Vec2;
export declare const asVec2: (x: Vec) => Vec2;
//# sourceMappingURL=vec2.d.ts.map
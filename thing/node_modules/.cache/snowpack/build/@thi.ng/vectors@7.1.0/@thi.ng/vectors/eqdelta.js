import { implementsFunction } from '@thi.ng/checks/implements-function';
import { EPS } from '@thi.ng/math/api';
import { eqDelta as eqDelta$1 } from '@thi.ng/math/eqdelta';
import { compileHOF } from './compile/emit.js';
import { vop } from './vop.js';
import '@thi.ng/transducers/comp';
import '@thi.ng/transducers/map';
import '@thi.ng/transducers/map-indexed';
import '@thi.ng/transducers/range';
import '@thi.ng/transducers/str';
import '@thi.ng/transducers/take';
import '@thi.ng/transducers/transduce';
import '@thi.ng/transducers/zip';
import './compile/templates.js';
import '@thi.ng/errors/unsupported';

const $ = (dim) => eqDelta.add(dim, compileHOF(dim, [eqDelta$1, EPS], ([a, b]) => `eq(${a},${b},eps)`, "eq,_eps", "a,b,eps=_eps", "a,b", "", "&&", "return a.length === b.length && ", ";"));
/**
 * Checks given vectors for componentwise equality, taking tolerance
 * `eps` (default: {@link @thi.ng/math#EPS}) into account.
 *
 * @param a
 * @param b
 * @param eps
 */
const eqDelta = vop();
eqDelta.default((v1, v2, eps = EPS) => {
    if (implementsFunction(v1, "eqDelta")) {
        return v1.eqDelta(v2, eps);
    }
    if (implementsFunction(v2, "eqDelta")) {
        return v2.eqDelta(v1, eps);
    }
    return eqDeltaS(v1, v2, v1.length, eps);
});
const eqDelta2 = $(2);
const eqDelta3 = $(3);
const eqDelta4 = $(4);
/**
 * Checks given strided vectors for componentwise equality, taking
 * tolerance `eps` (default: {@link @thi.ng/math#EPS}) into account.
 *
 * @param a - first vector
 * @param b - second vector
 * @param n - number of elements
 * @param eps - tolerance
 * @param ia - start index a
 * @param ib - start index b
 * @param sa - stride a
 * @param sb - stride b
 */
const eqDeltaS = (a, b, n, eps = EPS, ia = 0, ib = 0, sa = 1, sb = 1) => {
    for (; n > 0; n--, ia += sa, ib += sb) {
        if (!eqDelta$1(a[ia], b[ib], eps)) {
            return false;
        }
    }
    return true;
};
const eqDeltaArray = (a, b, eps = EPS) => {
    if (a === b)
        return true;
    if (a.length !== b.length)
        return false;
    for (let i = a.length; --i >= 0;) {
        if (!eqDelta(a[i], b[i], eps)) {
            return false;
        }
    }
    return true;
};
const isInArray = (p, pts, eps = EPS) => {
    for (let i = pts.length; --i >= 0;) {
        if (eqDelta(p, pts[i], eps)) {
            return true;
        }
    }
    return false;
};

export { eqDelta, eqDelta2, eqDelta3, eqDelta4, eqDeltaArray, eqDeltaS, isInArray };

import { X2, Y2, MIN2, MAX2, ZERO2, ONE2, X3, Y3, Z3, MIN3, MAX3, ZERO3, ONE3, X4, Y4, Z4, MIN4, MAX4, ZERO4, ONE4 } from './vectors/api.js';
export { MAX2, MAX3, MAX4, MIN2, MIN3, MIN4, ONE2, ONE3, ONE4, W4, X2, X3, X4, Y2, Y3, Y4, Z3, Z4, ZERO2, ZERO3, ZERO4 } from './vectors/api.js';
import { defFnOp, defBitOp, defBitOpN, defOp, defOpS, defHofOp, compile, compileG, defMathOp, defMathOpN, defHofOpS } from './vectors/compile/emit.js';
export { compile, compileG, compileGHOF, compileHOF, compileS, defBitOp, defBitOpN, defFnOp, defHofOp, defHofOpS, defMathOp, defMathOpN, defOp, defOpS, defaultOut } from './vectors/compile/emit.js';
import { ARGS_VVV, MATH2, SARGS_VVV, SARGS_VV, ARGS_VVN, MATH2_N, MATH, ARGS_V, SARGS_V, ARGS_VN, MATH_N, ARGS_VV, FN2, FN3, NEW_OUT, FN, FN5, ARGS_VNV, MATH2A_N, MIX, MIX_N, FN_N, NEW_OUT_A, SET_N, DEFAULT_OUT } from './vectors/compile/templates.js';
export { ARGS_V, ARGS_VN, ARGS_VNV, ARGS_VV, ARGS_VVN, ARGS_VVV, DEFAULT_OUT, DOT, DOT_G, FN, FN2, FN3, FN5, FN_N, MATH, MATH2, MATH2A_N, MATH2_N, MATH_N, MIX, MIX_N, NEW_OUT, NEW_OUT_A, SARGS_V, SARGS_VV, SARGS_VVV, SET, SET_N, SIGNED, SIGNED_N, UNSIGNED, UNSIGNED_N } from './vectors/compile/templates.js';
import { isFunction } from '@thi.ng/checks/is-function';
import { floatFixedWidth, float } from '@thi.ng/strings/float';
import { EPS } from '@thi.ng/math/api';
import { SIZEOF, typedArray } from '@thi.ng/api/typedarray';
import { eqDelta2, eqDelta3, eqDelta4, eqDeltaS } from './vectors/eqdelta.js';
export { eqDelta, eqDelta2, eqDelta3, eqDelta4, eqDeltaArray, eqDeltaS, isInArray } from './vectors/eqdelta.js';
import { floatToUintBits } from '@thi.ng/binary/float';
import { rotateLeft } from '@thi.ng/binary/rotate';
import { setS2, setS3, setS4, setS } from './vectors/sets.js';
export { setS, setS2, setS3, setS4 } from './vectors/sets.js';
import { vop } from './vectors/vop.js';
export { vop } from './vectors/vop.js';
export { abs, abs2, abs3, abs4 } from './vectors/abs.js';
import { addW4 } from './vectors/addw.js';
export { addW2, addW3, addW4, addW5 } from './vectors/addw.js';
import { add } from './vectors/add.js';
export { add, add2, add3, add4 } from './vectors/add.js';
import { addmN } from './vectors/addmn.js';
export { addmN, addmN2, addmN3, addmN4 } from './vectors/addmn.js';
export { addN, addN2, addN3, addN4 } from './vectors/addn.js';
export { angleBetween2, angleBetween3, angleRatio } from './vectors/angle-between.js';
export { b as bisect2, c as cornerBisector, a as cornerBisector2, f as heading, h as headingXY, d as headingXZ, e as headingYZ } from '../common/bisect-78791db8.js';
export { cartesian, cartesian2, cartesian3 } from './vectors/cartesian.js';
import { assert } from '@thi.ng/errors/assert';
import { mulN } from './vectors/muln.js';
export { mulN, mulN2, mulN3, mulN4 } from './vectors/muln.js';
import { set } from './vectors/set.js';
export { set, set2, set3, set4 } from './vectors/set.js';
import { sum } from './vectors/sum.js';
export { sum, sum2, sum3, sum4 } from './vectors/sum.js';
import { subN } from './vectors/subn.js';
export { subN, subN2, subN3, subN4 } from './vectors/subn.js';
import { clamp as clamp$1, clamp01 as clamp01$1, clamp11 as clamp11$1, max2id, max3id, max4id, min2id, min3id, min4id, wrap as wrap$1 } from '@thi.ng/math/interval';
export { clockwise2, corner2 } from './vectors/clockwise.js';
export { copy, copyVectors } from './vectors/copy.js';
import { mag } from './vectors/mag.js';
export { mag } from './vectors/mag.js';
import { mul } from './vectors/mul.js';
export { mul, mul2, mul3, mul4 } from './vectors/mul.js';
export { cross2, cross3 } from './vectors/cross.js';
import { deg, rad, atan2Abs } from '@thi.ng/math/angle';
export { direction } from './vectors/direction.js';
export { dist, dist2, dist3, dist4 } from './vectors/dist.js';
export { distSq, distSq2, distSq3, distSq4 } from './vectors/distsq.js';
export { div, div2, div3, div4 } from './vectors/div.js';
import { divN } from './vectors/divn.js';
export { divN, divN2, divN3, divN4 } from './vectors/divn.js';
import { dot } from './vectors/dot.js';
export { dot, dot2, dot3, dot4 } from './vectors/dot.js';
export { dotC4, dotC6, dotC8 } from './vectors/dotc.js';
import { dotS, dotS2, dotS3, dotS4 } from './vectors/dots.js';
export { dotS, dotS2, dotS3, dotS4 } from './vectors/dots.js';
export { empty } from './vectors/empty.js';
import { equivArrayLike } from '@thi.ng/equiv';
import { fit as fit$1, fit01 as fit01$1, fit11 as fit11$1 } from '@thi.ng/math/fit';
import { fract as fract$1, mod as mod$1, roundTo } from '@thi.ng/math/prec';
import { memoize1 } from '@thi.ng/memoize/memoize1';
import { map } from '@thi.ng/transducers/map';
import { range } from '@thi.ng/transducers/range';
import { zeroes, setN, zero } from './vectors/setn.js';
export { one, ones, setN, setN2, setN3, setN4, zero, zeroes } from './vectors/setn.js';
export { fromHomogeneous, fromHomogeneous3, fromHomogeneous4 } from './vectors/homogeneous.js';
import { SYSTEM } from '@thi.ng/random/system';
import { randNorm } from './vectors/random.js';
export { randMinMax, randMinMax2, randMinMax3, randMinMax4, randNorm, randNorm2, randNorm3, randNorm4, randNormDistrib, randNormDistrib2, randNormDistrib3, randNormDistrib4, random, random2, random3, random4, randomDistrib, randomDistrib2, randomDistrib3, randomDistrib4 } from './vectors/random.js';
export { madd, madd2, madd3, madd4 } from './vectors/madd.js';
import { maddN } from './vectors/maddn.js';
export { maddN, maddN2, maddN3, maddN4 } from './vectors/maddn.js';
import { magSq } from './vectors/magsq.js';
export { magSq, magSq2, magSq3, magSq4 } from './vectors/magsq.js';
import { isNumber } from '@thi.ng/checks/is-number';
import { max } from './vectors/max.js';
export { max, max2, max3, max4 } from './vectors/max.js';
import { min } from './vectors/min.js';
export { min, min2, min3, min4 } from './vectors/min.js';
export { mixBilinear, mixBilinear2, mixBilinear3, mixBilinear4 } from './vectors/mix-bilinear.js';
export { mixCubic } from './vectors/mix-cubic.js';
import { submN } from './vectors/submn.js';
export { submN, submN2, submN3, submN4 } from './vectors/submn.js';
export { mixQuadratic } from './vectors/mix-quadratic.js';
export { mixN, mixN2, mixN3, mixN4 } from './vectors/mixn.js';
export { neg } from './vectors/neg.js';
export { normalCCW, normalCW } from './vectors/normal.js';
export { normalize } from './vectors/normalize.js';
export { orthoNormal3 } from './vectors/ortho-normal.js';
export { perpendicularCCW, perpendicularCW } from './vectors/perpendicular.js';
export { pointOnRay, pointOnRay2, pointOnRay3 } from './vectors/point-on-ray.js';
import { setC2, setC3, setC4 } from './vectors/setc.js';
export { setC, setC2, setC3, setC4, setC6 } from './vectors/setc.js';
export { powN, powN2, powN3, powN4 } from './vectors/pown.js';
import { normal } from '@thi.ng/random/distributions/normal';
import { remainder as remainder$1 } from '@thi.ng/math/libc';
export { rotate, rotateX, rotateY, rotateZ } from './vectors/rotate.js';
import { safeDiv as safeDiv$1 } from '@thi.ng/math/safe-div';
export { setVV16, setVV4, setVV6, setVV9 } from './vectors/setvv.js';
export { signedArea2, signedAreaC2 } from './vectors/signed-area.js';
import { step as step$1, smoothStep as smoothStep$1 } from '@thi.ng/math/step';
export { sub, sub2, sub3, sub4 } from './vectors/sub.js';
import '@thi.ng/transducers/comp';
import '@thi.ng/transducers/map-indexed';
import '@thi.ng/transducers/str';
import '@thi.ng/transducers/take';
import '@thi.ng/transducers/transduce';
import '@thi.ng/transducers/zip';
import '@thi.ng/checks/implements-function';
import '@thi.ng/math/eqdelta';
import '@thi.ng/errors/unsupported';
import '@thi.ng/transducers/add';
import '@thi.ng/transducers/reduce';
import '@thi.ng/math/abs';
import '@thi.ng/math/mix';

function* vecIterator(ctor, buf, num, start, cstride, estride) {
    while (num-- > 0) {
        yield new ctor(buf, start, cstride);
        start += estride;
    }
}
function* stridedValues(buf, num, start, stride) {
    while (num-- > 0) {
        yield buf[start];
        start += stride;
    }
}

/** @internal */
const declareIndex = (proto, id, idx, strided = true, defNumeric = true) => {
    const get = idx > 0
        ? strided
            ? function () {
                return this.buf[this.offset + idx * this.stride];
            }
            : function () {
                return this.buf[this.offset + idx];
            }
        : function () {
            return this.buf[this.offset];
        };
    const set = idx > 0
        ? strided
            ? function (n) {
                this.buf[this.offset + idx * this.stride] = n;
            }
            : function (n) {
                this.buf[this.offset + idx] = n;
            }
        : function (n) {
            this.buf[this.offset] = n;
        };
    defNumeric &&
        Object.defineProperty(proto, idx, {
            get,
            set,
            enumerable: true,
        });
    Object.defineProperty(proto, id, {
        get,
        set,
        enumerable: true,
    });
};
/** @internal */
const declareIndices = (proto, props, strided, defNumeric) => props.forEach((id, i) => declareIndex(proto, id, i, strided, defNumeric));

/**
 * Returns a new generic vector formatter for given options (all optional). The
 * returned function accepts a single vector(like) value and returns its
 * formatted string representation.
 *
 * @remarks
 * See {@link ToStringOpts} for further details. Also see {@link setFormat} to
 * set default formatter.
 *
 * @example
 * ```ts
 * defFormat()([1, -2, 3])
 * // [1.000, -2.000, 3.000]
 *
 * defFormat({ width: 10, wrap: "||", delim: "|\n|" })([1, -2, 3])
 * // |     1.000|
 * // |    -2.000|
 * // |     3.000|
 *
 * defFormat({ prec: 5, delim: " " })([1, -2, 3])
 * // [1.00000 -2.00000 3.00000]
 * ```
 *
 * @param prec
 * @param width
 */
const defFormat = (opts) => {
    const { prec, width, delim, wrap } = {
        prec: 3,
        delim: ", ",
        wrap: "[]",
        ...opts,
    };
    const fmt = width ? floatFixedWidth(width, prec) : float(prec);
    return (src) => {
        let res = [];
        for (let x of src)
            res.push(fmt(x));
        return `${wrap[0]}${res.join(delim)}${wrap[1]}`;
    };
};
/**
 * Sets package-wide default vector formatter. See {@link defFormat},
 * {@link FORMATTER}.
 *
 * @param fmt
 */
const setFormat = (fmt) => {
    FORMATTER = isFunction(fmt) ? fmt : defFormat(fmt);
};
/**
 * Package-wide default vector formatter.
 */
let FORMATTER = defFormat();

class AVec {
    constructor(buf, offset = 0, stride = 1) {
        this.buf = buf;
        this.offset = offset;
        this.stride = stride;
    }
    toString() {
        return FORMATTER(this);
    }
}

/**
 * Takes an `ArrayBuffer` and creates a number of typed array vector
 * views of `type` with given `size` (number of elements per vector) and
 * spacing. `byteOffset` defines the start offset for the first vector
 * and `byteStride` the number of bytes between resulting vectors
 * (defaults to `size * SIZEOF[type]`). It's user's responsibility to
 * ensure these two values are compatible with the chosen array type
 * (i.e. for `"f32"`, these MUST be multiples of 4).
 *
 * @example
 * ```ts
 * mapBuffer("f32", new ArrayBuffer(32), 4, 2)
 * // [
 * //   Float32Array [ 0, 0 ],
 * //   Float32Array [ 0, 0 ],
 * //   Float32Array [ 0, 0 ],
 * //   Float32Array [ 0, 0 ]
 * // ]
 * ```
 *
 * @param type -
 * @param buf -
 * @param num -
 * @param size -
 * @param byteOffset -
 * @param byteStride -
 */
const mapBuffer = (type, buf, num, size, byteOffset = 0, byteStride = size * SIZEOF[type]) => {
    const res = [];
    for (; --num >= 0; byteOffset += byteStride) {
        res.push(typedArray(type, buf, byteOffset, size));
    }
    return res;
};
/**
 * Writes given `src` vector values into mapped `ArrayBuffer` of stated
 * `type` and from given offset & stride/spacing.
 *
 * {@link mapBuffer}
 *
 * @param type -
 * @param buf -
 * @param src -
 * @param byteOffset -
 * @param byteStride -
 */
const intoBuffer = (type, buf, src, byteOffset, byteStride) => {
    const view = typedArray(type, buf);
    const size = SIZEOF[type];
    byteOffset /= size;
    byteStride /= size;
    for (let x of src) {
        view.set(x, byteOffset);
        byteOffset += byteStride;
    }
};
const mapStridedBuffer = (ctor, buf, num, start, cstride, estride) => {
    const res = [];
    while (--num >= 0) {
        res.push(new ctor(buf, start, cstride));
        start += estride;
    }
    return res;
};
const intoStridedBuffer = (set, buf, src, start, cstride, estride) => {
    for (let v of src) {
        set(buf, v, start, 0, cstride, 1);
        start += estride;
    }
    return buf;
};

/**
 * Returns an unsigned 32-bit hash code for the given vector.
 *
 * @remarks
 * The hash is the reduction of `hash = H * hash + murmur(x)`, where
 * `murmur(x)` is the partial Murmur3 hash of a single vector
 * component's bitwise representation and `H` an optional hash factor,
 * by default Knuth's 0x9e3779b1 (see TAOCP, section 6.4, page 516). If
 * the vector `v` is empty (length 0), the function returns -1.
 *
 * Hashes for zero-vectors:
 *
 * - `[0]`: 1209856430
 * - `[0, 0]`: 3623989185
 * - `[0, 0, 0]`: 4192292821
 * - `[0, 0, 0, 0]`: 2558592725
 *
 * @example
 * Hash collisions:
 *
 * ```ts
 * // integer grid coords
 * uniq = tx.transduce(tx.map(v.hash32), tx.conj(), tx.range2d(0x1000, 0x1000)).size
 * // 16744420
 *
 * // collision rate
 * (1 - uniq / (0x1000 ** 2)) * 100
 * // 0.1955 %
 *
 * // normalized grid coords
 * uniq = tx.transduce(
 *   tx.map(v.hash32),
 *   tx.conj(),
 *   tx.permutations(tx.normRange(1000), tx.normRange(1000))
 * ).size
 * // 1001895
 *
 * // collision rate
 * (1 - uniq / (1001 ** 2)) * 100
 * // 0.0106 %
 * ```
 *
 * - {@link https://github.com/thi-ng/c-thing/blob/develop/src/math/hashfn.c}
 * - {@link @thi.ng/morton# | @thi.ng/morton} for Z-curve ordered hashing
 *
 * @param v - vector
 * @param hash - hash factor
 */
const hash = (v, H = 0x9e3779b1) => {
    let hash = -1;
    for (let i = v.length; --i >= 0;) {
        hash = (Math.imul(H, hash) + mix(hash, floatToUintBits(v[i]))) >>> 0;
    }
    return hash;
};
const M1 = 0xcc9e2d51;
const M2 = 0x1b873593;
const M3 = 0xe6546b64;
const mix = (h, k) => {
    k = Math.imul(rotateLeft(Math.imul(k, M1) >>> 0, 15), M2) >>> 0;
    return ((Math.imul(rotateLeft(h ^ k, 13), 5) >>> 0) + M3) >>> 0;
};

class Vec2 extends AVec {
    constructor(buf, offset = 0, stride = 1) {
        super(buf || [0, 0], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec2} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XY vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */
    static mapBuffer(buf, num = buf.length >> 1, start = 0, cstride = 1, estride = 2) {
        return mapStridedBuffer(Vec2, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec2}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec2.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */
    static intoBuffer(buf, src, start = 0, cstride = 1, estride = 2) {
        return intoStridedBuffer(setS2, buf, src, start, cstride, estride);
    }
    static iterator(buf, num, start = 0, cstride = 1, estride = 2) {
        return vecIterator(Vec2, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return stridedValues(this.buf, 2, this.offset, this.stride);
    }
    get length() {
        return 2;
    }
    copy() {
        return new Vec2([this.x, this.y]);
    }
    copyView() {
        return new Vec2(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec2();
    }
    eqDelta(v, eps = EPS) {
        return eqDelta2(this, v, eps);
    }
    hash() {
        return hash(this);
    }
    toJSON() {
        return [this.x, this.y];
    }
}
Vec2.X_AXIS = new Vec2(X2);
Vec2.Y_AXIS = new Vec2(Y2);
Vec2.MIN = new Vec2(MIN2);
Vec2.MAX = new Vec2(MAX2);
Vec2.ZERO = new Vec2(ZERO2);
Vec2.ONE = new Vec2(ONE2);
declareIndices(Vec2.prototype, ["x", "y"]);
const vec2 = (x = 0, y = 0) => new Vec2([x, y]);
const vec2n = (n) => new Vec2([n, n]);
const asVec2 = (x) => x instanceof Vec2
    ? x
    : new Vec2(x.length >= 2 ? x : [x[0] || 0, x[1] || 0]);

class Vec3 extends AVec {
    constructor(buf, offset = 0, stride = 1) {
        super(buf || [0, 0, 0], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec3} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XYZ vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */
    static mapBuffer(buf, num = (buf.length / 3) | 0, start = 0, cstride = 1, estride = 3) {
        return mapStridedBuffer(Vec3, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec3}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec3.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */
    static intoBuffer(buf, src, start = 0, cstride = 1, estride = 3) {
        return intoStridedBuffer(setS3, buf, src, start, cstride, estride);
    }
    static iterator(buf, num, start = 0, cstride = 1, estride = 3) {
        return vecIterator(Vec3, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return stridedValues(this.buf, 3, this.offset, this.stride);
    }
    get length() {
        return 3;
    }
    copy() {
        return new Vec3([this.x, this.y, this.z]);
    }
    copyView() {
        return new Vec3(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec3();
    }
    eqDelta(v, eps = EPS) {
        return eqDelta3(this, v, eps);
    }
    hash() {
        return hash(this);
    }
    toJSON() {
        return [this.x, this.y, this.z];
    }
}
Vec3.X_AXIS = new Vec3(X3);
Vec3.Y_AXIS = new Vec3(Y3);
Vec3.Z_AXIS = new Vec3(Z3);
Vec3.MIN = new Vec3(MIN3);
Vec3.MAX = new Vec3(MAX3);
Vec3.ZERO = new Vec3(ZERO3);
Vec3.ONE = new Vec3(ONE3);
declareIndices(Vec3.prototype, ["x", "y", "z"]);
const vec3 = (x = 0, y = 0, z = 0) => new Vec3([x, y, z]);
const vec3n = (n) => new Vec3([n, n, n]);
const asVec3 = (x) => x instanceof Vec3
    ? x
    : new Vec3(x.length >= 3
        ? x
        : [x[0] || 0, x[1] || 0, x[2] || 0]);

class Vec4 extends AVec {
    constructor(buf, offset = 0, stride = 1) {
        super(buf || [0, 0, 0, 0], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec4} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XYZ vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */
    static mapBuffer(buf, num = buf.length >> 2, start = 0, cstride = 1, estride = 4) {
        return mapStridedBuffer(Vec4, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec4}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec4.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */
    static intoBuffer(buf, src, start = 0, cstride = 1, estride = 4) {
        return intoStridedBuffer(setS4, buf, src, start, cstride, estride);
    }
    static *iterator(buf, num, start = 0, cstride = 1, estride = 4) {
        return vecIterator(Vec4, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return stridedValues(this.buf, 4, this.offset, this.stride);
    }
    get length() {
        return 4;
    }
    copy() {
        return new Vec4([this.x, this.y, this.z, this.w]);
    }
    copyView() {
        return new Vec4(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec4();
    }
    eqDelta(v, eps = EPS) {
        return eqDelta4(this, v, eps);
    }
    hash() {
        return hash(this);
    }
    toJSON() {
        return [this.x, this.y, this.z, this.w];
    }
}
Vec4.X_AXIS = new Vec4(X4);
Vec4.Y_AXIS = new Vec4(Y4);
Vec4.Z_AXIS = new Vec4(Z4);
Vec4.MIN = new Vec4(MIN4);
Vec4.MAX = new Vec4(MAX4);
Vec4.ZERO = new Vec4(ZERO4);
Vec4.ONE = new Vec4(ONE4);
declareIndices(Vec4.prototype, ["x", "y", "z", "w"]);
const vec4 = (x = 0, y = 0, z = 0, w = 0) => new Vec4([x, y, z, w]);
const vec4n = (n) => new Vec4([n, n, n, n]);
const asVec4 = (x) => x instanceof Vec4
    ? x
    : new Vec4(x.length >= 4
        ? x
        : [x[0] || 0, x[1] || 0, x[2] || 0, x[3] || 0]);

const [acos, acos2, acos3, acos4] = defFnOp("Math.acos");

const [addI, addI2, addI3, addI4] = defBitOp("+", true);
const [addU, addU2, addU3, addU4] = defBitOp("+");
const [addNI, addNI2, addNI3, addNI4] = defBitOpN("+", true);
const [addNU, addNU2, addNU3, addNU4] = defBitOpN("+");

/**
 * Returns `out = (a + b) * c`.
 *
 * - {@link madd}
 * - {@link subm}
 */
const [addm, addm2, addm3, addm4] = defOp(MATH2("+", "*"), ARGS_VVV);

const [addmS, addmS2, addmS3, addmS4] = defOpS(MATH2("+", "*"), ARGS_VVV, SARGS_VVV, ARGS_VVV);

const [addmNS, addmNS2, addmNS3, addmNS4] = defOpS(MATH2_N("+", "*"), ARGS_VVN, SARGS_VV);

const [addS, addS2, addS3, addS4] = defOpS(MATH("+"));

const [addNS, addNS2, addNS3, addNS4] = defOpS(MATH_N("+"), ARGS_VN, SARGS_V, ARGS_V);

const [asin, asin2, asin3, asin4] = defFnOp("Math.asin");

const [atan, atan2, atan3, atan4] = defFnOp("Math.atan");
const [atan_2, atan_22, atan_23, atan_24] = defOp(FN2("Math.atan2"), ARGS_VV);

const [bitAndI, bitAndI2, bitAndI3, bitAndI4] = defBitOp("&", true);
const [bitAndU, bitAndU2, bitAndU3, bitAndU4] = defBitOp("&");
const [bitAndNI, bitAndNI2, bitAndNI3, bitAndNI4] = defBitOpN("&", true);
const [bitAndNU, bitAndNU2, bitAndNU3, bitAndNU4] = defBitOpN("&");

const [bitNotI, bitNotI2, bitNotI3, bitNotI4] = defOp(([o, a]) => `${o}=(~${a})|0;`, ARGS_V);
const [bitNotU, bitNotU2, bitNotU3, bitNotU4] = defOp(([o, a]) => `${o}=(~${a})>>>0;`, ARGS_V);

const [bitOrI, bitOrI2, bitOrI3, bitOrI4] = defBitOp("|", true);
const [bitOrU, bitOrU2, bitOrU3, bitOrU4] = defBitOp("|");
const [bitOrNI, bitOrNI2, bitOrNI3, bitOrNI4] = defBitOpN("|", true);
const [bitOrNU, bitOrNU2, bitOrNU3, bitOrNU4] = defBitOpN("|");

const [bitXorI, bitXorI2, bitXorI3, bitXorI4] = defBitOp("^", true);
const [bitXorU, bitXorU2, bitXorU3, bitXorU4] = defBitOp("^");
const [bitXorNI, bitXorNI2, bitXorNI3, bitXorNI4] = defBitOpN("^", true);
const [bitXorNU, bitXorNU2, bitXorNU3, bitXorNU4] = defBitOpN("^");

const [ceil, ceil2, ceil3, ceil4] = defFnOp("Math.ceil");

/**
 * Asserts that `src` has at least 1 item.
 *
 * @internal
 */
const __ensureInputs = (src) => assert(src.length > 0, `no inputs given`);

/**
 * Takes an array of vectors (of uniform dimensions) and computes the
 * componentwise mean. Writes result to `out` (or a new vector).
 *
 * @remarks
 * Also see {@link median}.
 *
 * @example
 * ```ts
 * mean([], [[3, 10, 400], [4, 30, 100], [1, 40, 200], [2, 20, 300]])
 * // [ 2.5, 25, 250 ]
 * ```
 *
 * @param out
 * @param src
 */
const mean = (out, src) => {
    __ensureInputs(src);
    out = set(out || [], src[0]);
    for (let i = src.length; --i >= 1;) {
        add(out, out, src[i]);
    }
    return mulN(out, out, 1 / src.length);
};
/**
 * Computes the mean of components of given vector.
 *
 * @example
 * ```ts
 * vmean([5, 10, 15, 20])
 * // 12.5
 * ```
 *
 * @param a
 */
const vmean = (a) => sum(a) / a.length;

/**
 * Creates a mean-centered version of `a`, i.e. subtracts {@link vmean} of `a`
 * from each component and writes result to `out` (or back into `a` iff `out` is
 * null).
 *
 * @param out
 * @param a
 */
const center = (out, a) => subN(out, a, vmean(a));

const [clamp, clamp2, clamp3, clamp4] = defHofOp(clamp$1, FN3(), ARGS_VVV);
const [clamp01, clamp01_2, clamp01_3, clamp01_4] = defHofOp(clamp01$1, FN3(), ARGS_VVV);
const [clamp11, clamp11_2, clamp11_3, clamp11_4] = defHofOp(clamp11$1, FN3(), ARGS_VVV);

const [clampN, clampN2, clampN3, clampN4] = defHofOp(clamp$1, ([o, a]) => `${o}=op(${a},n,m);`, "o,a,n,m", "o,a");

/**
 * Returns a new 2D vector comparator using given component order. The
 * comparator returns the signed index+1 of the first differing
 * component, e.g. if order is `0,1`, a return value of -2 means that
 * `a.y < b.y`.
 *
 * @param o1 -
 * @param o2 -
 */
const comparator2 = (o1, o2) => (a, b) => {
    const ax = a[o1];
    const ay = a[o2];
    const bx = b[o1];
    const by = b[o2];
    return ax === bx
        ? ay === by
            ? 0
            : ay < by
                ? -2
                : 2
        : ax < bx
            ? -1
            : 1;
};
/**
 * Returns a new 3D vector comparator using given component order. The
 * comparator returns the signed index+1 of the first differing
 * component, e.g. if order is `0,1,2`, a return value of -3 means that
 * `a.z < b.z`.
 *
 * @param o1 -
 * @param o2 -
 * @param o3 -
 */
const comparator3 = (o1, o2, o3) => (a, b) => {
    const ax = a[o1];
    const ay = a[o2];
    const az = a[o3];
    const bx = b[o1];
    const by = b[o2];
    const bz = b[o3];
    return ax === bx
        ? ay === by
            ? az === bz
                ? 0
                : az < bz
                    ? -3
                    : 3
            : ay < by
                ? -2
                : 2
        : ax < bx
            ? -1
            : 1;
};
/**
 * Returns a new 4D vector comparator using given component order. The
 * comparator returns the signed index+1 of the first differing
 * component, e.g. if order is `0,1,2,3`, a return value of -4 means
 * that `a.w < b.w`.
 *
 * @param o1 -
 * @param o2 -
 * @param o3 -
 * @param o4 -
 */
const comparator4 = (o1, o2, o3, o4) => (a, b) => {
    const ax = a[o1];
    const ay = a[o2];
    const az = a[o3];
    const aw = b[o4];
    const bx = b[o1];
    const by = b[o2];
    const bz = b[o3];
    const bw = b[o4];
    return ax === bx
        ? ay === by
            ? az === bz
                ? aw === bw
                    ? 0
                    : aw < bw
                        ? -4
                        : 4
                : az < bz
                    ? -3
                    : 3
            : ay < by
                ? -2
                : 2
        : ax < bx
            ? -1
            : 1;
};

const $ = (tpl, pre = NEW_OUT) => defOp(tpl, ARGS_V, ARGS_V, "o", 1, pre);
const [asIVec, asIVec2, asIVec3, asIVec4] = $(([o, a]) => `${o}=${a}|0;`);
const [asUVec, asUVec2, asUVec3, asUVec4] = $(([o, a]) => `${o}=${a}>>>0;`);
const [asBVec, asBVec2, asBVec3, asBVec4] = $(([o, a]) => `${o}=!!${a};`);
const [fromBVec, fromBVec2, fromBVec3, fromBVec4] = $(([o, a]) => `${o}=~~${a};`);

/**
 * Computes the Pearson correlation coefficient between `a` and `b`. Returns
 * `undefined` if the denominator (see below) is zero.
 *
 * @remarks
 * ```text
 * sum(a' * b') / (mag(a') * mag(b'))
 * ```
 *
 * ...where `a'` and `b'` are {@link center}'ed versions of given input vectors.
 *
 * References:
 * - https://en.wikipedia.org/wiki/Correlation
 * - https://www.youtube.com/watch?v=2bcmklvrXTQ
 *
 * @param a
 * @param b
 */
const correlation = (a, b) => {
    a = center([], a);
    b = center([], b);
    const m = mag(a) * mag(b);
    return m !== 0 ? sum(mul(null, a, b)) / m : undefined;
};

const [cos, cos2, cos3, cos4] = defFnOp("Math.cos");

const [cosh, cosh2, cosh3, cosh4] = defFnOp("Math.cosh");

/**
 * Computes the covariance coefficient between the two given vectors.
 *
 * @remarks
 * References:
 * - https://en.wikipedia.org/wiki/Covariance
 * - https://www.youtube.com/watch?v=2bcmklvrXTQ
 *
 * @param a
 * @param b
 */
const covariance = (a, b) => sum(mul(null, center([], a), center([], b))) / (a.length - 1);

const setCS2 = (out, x, y, io = 0, so = 1) => (!out && (out = []), (out[io] = x), (out[io + so] = y), out);
const setCS3 = (out, x, y, z, io = 0, so = 1) => (!out && (out = []),
    (out[io] = x),
    (out[io + so] = y),
    (out[io + 2 * so] = z),
    out);
const setCS4 = (out, x, y, z, w, io = 0, so = 1) => (!out && (out = []),
    (out[io] = x),
    (out[io + so] = y),
    (out[io + 2 * so] = z),
    (out[io + 3 * so] = w),
    out);

const crossS2 = (a, b, ia = 0, ib = 0, sa = 1, sb = 1) => a[ia] * b[ib + sb] - a[ia + sa] * b[ib];
const crossS3 = (out, a, b, io = 0, ia = 0, ib = 0, so = 1, sa = 1, sb = 1) => setCS3(out || a, a[ia + sa] * b[ib + 2 * sb] - a[ia + 2 * sa] * b[ib + sb], a[ia + 2 * sa] * b[ib] - a[ia] * b[ib + 2 * sb], a[ia] * b[ib + sb] - a[ia + sa] * b[ib], io, so);

const [degrees, degrees2, degrees3, degrees4] = defHofOp(deg, FN("op"));

/**
 * Bray-Curtis **dissimilarity** metric. Result always in [0..1] interval.
 *
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/Bray%E2%80%93Curtis_dissimilarity
 *
 * @example
 * ```ts
 * distBrayCurtis([6, 7, 4], [10, 0, 6])
 * // 0.393939...
 * ```
 *
 * @param a
 * @param b
 */
const distBrayCurtis = (a, b) => {
    let c = 0;
    let s = 0;
    for (let i = a.length; i-- > 0;) {
        c += Math.abs(a[i] - b[i]);
        s += Math.abs(a[i] + b[i]);
    }
    return s > 0 ? c / s : 0;
};

/**
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/Canberra_distance
 *
 * @param a
 * @param b
 */
const distCanberra = (a, b) => {
    let delta = 0;
    for (let i = a.length; --i >= 0;) {
        const aa = a[i];
        const bb = b[i];
        const d = Math.abs(aa) + Math.abs(bb);
        d > 0 && (delta += Math.abs(aa - bb) / d);
    }
    return delta;
};

const $$1 = (dim) => distChebyshev.add(dim, compile(dim, ([a, b]) => `Math.abs(${a}-${b})`, "a,b", undefined, "", ",", "return Math.max(", ");"));
/**
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/Chebyshev_distance
 */
const distChebyshev = vop();
distChebyshev.default((a, b) => {
    let max = 0;
    for (let i = a.length; --i >= 0;) {
        max = Math.max(max, Math.abs(a[i] - b[i]));
    }
    return max;
});
const distChebyshev2 = $$1(2);
const distChebyshev3 = $$1(3);
const distChebyshev4 = $$1(4);

/**
 * Normalized Hamming distance between `a` and `b`, i.e. number of differing
 * components divided by vector size.
 *
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/Hamming_distance
 *
 * @param a
 * @param b
 */
const distHamming = (a, b) => {
    let delta = 0;
    for (let i = a.length; --i >= 0;) {
        a[i] !== b[i] && delta++;
    }
    return delta / a.length;
};

const [radians, radians2, radians3, radians4] = defHofOp(rad, FN("op"));

/**
 * Returns distance between 2 points along a great circle on a sphere, using the
 * Haversine formula, with each point given as [lat, lon] (in WGS84 format).
 * Uses Earth's radius `r=6371` by default, therefore returns distance in km (by
 * default).
 *
 * @remarks
 * References:
 * - https://en.wikipedia.org/wiki/Haversine_formula
 * - https://stackoverflow.com/a/21623206
 *
 * @param a
 * @param b
 * @param r
 */
const distHaversineLatLon = (a, b, r = 6371) => {
    a = radians2([], a);
    b = radians2([], b);
    return dist(a[0], a[1], b[0], b[1], r);
};
/**
 * Same as {@link distHaversineLatLon}, only for coordinates defined in
 * [lon,lat] order.
 *
 * @param a
 * @param b
 * @param r
 * @returns
 */
const distHaversineLonLat = (a, b, r = 6371) => {
    a = radians2([], a);
    b = radians2([], b);
    return dist(a[1], a[0], b[1], b[0], r);
};
/**
 * @deprecated use {@link distHaversineLonLat} instead
 */
const distHaversine = distHaversineLonLat;
const dist = (lat1, lon1, lat2, lon2, r) => {
    const dlat = 0.5 - Math.cos(lat2 - lat1) * 0.5;
    const dlon = (1 - Math.cos(lon2 - lon1)) * 0.5;
    const combined = dlat + Math.cos(lat1) * Math.cos(lat2) * dlon;
    return 2 * r * Math.asin(Math.sqrt(combined));
};

/**
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/Jaccard_index
 *
 * @param a
 * @param b
 */
const distJaccard = (a, b) => {
    let numNZ = 0;
    let numEQ = 0;
    for (let i = a.length; --i >= 0;) {
        const aa = a[i] !== 0;
        const bb = b[i] !== 0;
        numNZ += ~~(aa || bb);
        numEQ += ~~(aa && bb);
    }
    return numNZ ? (numNZ - numEQ) / numNZ : 0;
};

const $$2 = (dim) => distManhattan.add(dim, compile(dim, ([a, b]) => `Math.abs(${a}-${b})`, "a,b", undefined, "", "+", "return ", ";"));
/**
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/Taxicab_geometry
 */
const distManhattan = vop();
distManhattan.default(compileG(([a, b]) => `sum+=Math.abs(${a}-${b});`, "a,b", undefined, "sum", "let sum=0;"));
const distManhattan2 = $$2(2);
const distManhattan3 = $$2(3);
const distManhattan4 = $$2(4);

/**
 * @remarks
 * The Minkowski power `p` MUST be > 0.
 *
 * Reference: https://en.wikipedia.org/wiki/Minkowski_distance
 *
 * @param a
 * @param b
 * @param p
 */
const distMinkowski = (a, b, p) => {
    let delta = 0;
    for (let i = a.length; --i >= 0;) {
        delta += Math.abs(a[i] - b[i]) ** p;
    }
    return delta ** (1 / p);
};

/**
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient
 *
 * @param a
 * @param b
 */
const distSorensenDice = (a, b) => {
    let numTP = 0;
    let numFP = 0;
    for (let i = a.length; i-- > 0;) {
        const aa = a[i] !== 0;
        const bb = b[i] !== 0;
        numTP += ~~(aa && bb);
        numFP += ~~(aa !== bb);
    }
    return numFP ? numFP / (2 * numTP + numFP) : 0;
};

/**
 * Higher order distance function. Takes an existing {@link DistanceFn} `fn` and
 * a vector of `weights` to control impact of each dimension. Returns new
 * {@link DistanceFn}, which when called, first applies `weights` to both inputs
 * and then uses `fn` to compute distance between the weighted results.
 *
 * @example
 * ```ts
 * const distXZ = weightedDistance(dist3, [1,0,1]);
 *
 * // distance in XZ plane only
 * distXZ(ONE3, ZERO3);
 * // 1.4142135623730951
 *
 * // compare with full eucledian distance
 * dist3(ONE3, ZERO3);
 * // 1.7320508075688772
 * ```
 *
 * @param fn
 * @param weights
 */
const weightedDistance = (fn, weights) => (a, b) => fn(mul([], a, weights), mul([], b, weights));

const [divI, divI2, divI3, divI4] = defBitOp("/", true);
const [divU, divU2, divU3, divU4] = defBitOp("/");
const [divNI, divNI2, divNI3, divNI4] = defBitOpN("/", true);
const [divNU, divNU2, divNU3, divNU4] = defBitOpN("/");

const [divS, divS2, divS3, divS4] = defOpS(MATH("/"));

const [divNS, divNS2, divNS3, divNS4] = defOpS(MATH_N("/"), ARGS_VN, SARGS_V, ARGS_V);

const equals = vop(0);
const equals2 = equals.add(2, (a, b) => a[0] === b[0] && a[1] === b[1]);
const equals3 = equals.add(3, (a, b) => a[0] === b[0] && a[1] === b[1] && a[2] === b[2]);
const equals4 = equals.add(4, (a, b) => a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]);
equals.default(equivArrayLike);

/**
 * Returns returns true if all vector components in `v` are truthy.
 *
 * @param v -
 */
const every = vop();
every.default((v) => {
    for (let i = v.length; --i >= 0;) {
        if (!v[i])
            return false;
    }
    return true;
});
const every2 = every.add(2, (a) => a[0] && a[1]);
const every3 = every.add(3, (a) => a[0] && a[1] && a[2]);
const every4 = every.add(4, (a) => a[0] && a[1] && a[2] && a[3]);

const [exp, exp2, exp3, exp4] = defFnOp("Math.exp");

/**
 * Componentwise 2^x
 */
const [exp_2, exp_22, exp_23, exp_24] = defOp(([o, a]) => `${o}=Math.pow(2,${a});`, ARGS_V);

const faceForward = (out, n, i, nref) => {
    !out && (out = n);
    return dot(nref, i) < 0
        ? out !== n
            ? set(out, n)
            : out
        : mulN(out, n, -1);
};

/**
 * Vec2/3/4 view based buffer transformation for {@link VecOpVV} type
 * ops and supporting arbitrary component and element layouts of all
 * input and output buffers.
 *
 * @remarks
 * The given pre-initialized vectors MUST be separate instances, are
 * used as sliding cursors / views of their respective backing buffers
 * and will be modified as part of the transformation process (though
 * the input buffers themselves are treated as immutable, unless `out`
 * is configured to use one of the input buffers).
 *
 * In each iteration `op` is called via `op(out, a, b)`, followed by
 * cursor updates to process the next vector view. No bounds checking is
 * performed.
 *
 * This function returns `out`'s backing buffer.
 *
 * @example
 * ```ts
 * // each input buffer contains 2 2D vectors, but using
 * // different strided data layouts
 * mapVV(
 *   // transformation function
 *   add,
 *   // init output buffer view
 *   new Vec2(),
 *   // wrap 1st input buffer & configure offset & component stride
 *   new Vec2([1,0,2,0,0,0,0,0,3,0,4,0,0,0,0,0], 0, 2),
 *   // wrap 2nd input buffer
 *   new Vec2([0,10,0,0,20,0,0,30,0,0,40], 1, 3),
 *   2, // num vectors
 *   2, // output element stride
 *   8, // input #1 element stride
 *   6  // input #2 element stride
 * );
 * // [ 11, 22, 33, 44 ]
 * ```
 *
 * Alternatively, `Vec2/3/4.iterator()` combined with transducers can be
 * used to achieve the same (and more flexible) transformations, but
 * will incur more intermediate object allocations. `mapV*()` functions
 * only use (and mutate) the provided vector instances and do not
 * allocate any further objects.
 *
 * ```ts
 * // output buffer
 * const out = new Array(4);
 *
 * tx.run(
 *   tx.map(([o, a, b]) => add(o, a, b)),
 *   tx.zip(
 *      Vec2.iterator(out, 2),
 *      Vec2.iterator([1,0,2,0,0,0,0,0,3,0,4,0,0,0,0,0], 2, 0, 2, 8),
 *      Vec2.iterator([0,10,0,0,20,0,0,30,0,0,40], 2, 1, 3, 6),
 *   )
 * );
 *
 * out
 * // [ 11, 22, 33, 44 ]
 * ```
 *
 * @param op -
 * @param out -
 * @param a -
 * @param b -
 * @param num -
 * @param so -
 * @param sa -
 * @param sb -
 */
const mapVV = (op, out, a, b, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride) => {
    while (num-- > 0) {
        op(out, a, b);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
    }
    return out.buf;
};
/**
 * Like {@link mapVV}, but for {@link VecOpV} type ops and hence only using
 * single input.
 *
 * @example
 * ```ts
 * // 4x 2D vectors in SOA layout
 * // i.e. [x1, x2, x3, x4, y1, y2, y3, y4]
 * buf = [1, 3, 5, 7, 2, 4, 6, 8];
 *
 * // use `swapXY` to swizzle each vector and use AOS for output
 * res = mapV(swapXY, new Vec2(), new Vec2(buf, 0, 4), 4, 2, 1);
 * // [ 2, 1, 4, 3, 6, 5, 8, 7 ]
 *
 * // unpack result for demonstration purposes
 * [...Vec2.iterator(res, 4)].map(v => [...v]);
 * // [ [ 2, 1 ], [ 4, 3 ], [ 6, 5 ], [ 8, 7 ] ]
 * ```
 *
 * @param op -
 * @param out -
 * @param a -
 * @param num -
 * @param so -
 * @param sa -
 */
const mapV = (op, out, a, num, so = out.length * out.stride, sa = a.length * a.stride) => {
    while (num-- > 0) {
        op(out, a);
        out.offset += so;
        a.offset += sa;
    }
    return out.buf;
};
/**
 * Like {@link mapVV}, but for {@link VecOpVN} type ops and hence using
 * a single vector input buffer `a` and a scalar `n`.
 *
 * @param op -
 * @param out -
 * @param a -
 * @param n -
 * @param num -
 * @param so -
 * @param sa -
 */
const mapVN = (op, out, a, n, num, so = out.length * out.stride, sa = a.length * a.stride) => {
    while (num-- > 0) {
        op(out, a, n);
        out.offset += so;
        a.offset += sa;
    }
    return out.buf;
};
/**
 * Like {@link mapVV}, but for {@link VecOpVVV} type ops and hence using
 * three vector input buffers `a`, `b`, `c`.
 *
 * @param op -
 * @param out -
 * @param a -
 * @param b -
 * @param c -
 * @param num -
 * @param so -
 * @param sa -
 * @param sb -
 * @param sc -
 */
const mapVVV = (op, out, a, b, c, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride, sc = c.length * c.stride) => {
    while (num-- > 0) {
        op(out, a, b, c);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
        c.offset += sc;
    }
    return out.buf;
};
/**
 * Like {@link mapVV}, but for {@link VecOpVVN} type ops and hence using
 * two vector input buffers `a`, `b` and a scalar `n`.
 *
 * @param op -
 * @param out -
 * @param a -
 * @param b -
 * @param n -
 * @param num -
 * @param so -
 * @param sa -
 * @param sb -
 */
const mapVVN = (op, out, a, b, n, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride) => {
    while (num-- > 0) {
        op(out, a, b, n);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
    }
    return out.buf;
};

/**
 * Fills Vec2/3/4 view based buffer, supporting arbitrary component and
 * element layouts of both the input and output buffers. The `out`
 * vector is used as write cursor over the underlying buffer and will be
 * filled with the components of vector `v`.
 *
 * @example
 * ```ts
 * fill(
 *   new Vec2(new Float32Array(12)),
 *   new Vec2([1, 2]),
 *   3, // num elements
 *   4  // stride
 * )
 * // Float32Array [1, 2, 0, 0, 1, 2, 0, 0, 1, 2, 0, 0]
 * ```
 *
 * @param out - target vector / wrapped buffer
 * @param v - fill vector
 * @param num - number of elements to fill
 * @param so - output stride
 */
const fill = (out, v, num, so = out.length * out.stride) => mapV(set.impl(v.length), out, v, num, so, 0);

const [fit, fit2, fit3, fit4] = defHofOp(fit$1, FN5(), "o,a,b,c,d,e");
const [fit01, fit01_2, fit01_3, fit01_4] = defHofOp(fit01$1, FN3(), ARGS_VVV);
const [fit11, fit11_2, fit11_3, fit11_4] = defHofOp(fit11$1, FN3(), ARGS_VVV);

const [floor, floor2, floor3, floor4] = defFnOp("Math.floor");

/**
 * Similar to {@link mod}, {@link remainder}. This version of modulo uses the
 * same logic as the standard C function `fmod` and/or the JS `%` operator,
 * yielding results with the same sign as `a`, i.e. computes `a-b*trunc(a/b)`.
 *
 * @remarks
 * **Caution:** Due to the introduction of libc math functions in thi.ng/math
 * v4.0.0 and the resulting name/behavior clashes between the modulo logic in
 * JS, C & GLSL, this function previously _was_ called `mod`, but going forward
 * has been renamed/swapped to align w/ its C version and now exhibits a
 * different behavior than the current {@link mod} function.
 */
const [fmod, fmod2, fmod3, fmod4] = defMathOp("%");

/**
 * Same as {@link fmod}, but 2nd operand is a single scalar (uniform domain for
 * all vector components).
 */
const [fmodN, fmodN2, fmodN3, fmodN4] = defMathOpN("%");

const [fract, fract2, fract3, fract4] = defHofOp(fract$1);

const SYM_B = "buf";
const SYM_L = "length";
const SYM_O = "offset";
const SYM_S = "stride";
const SYM_C = "copy";
const SYM_CV = "copyView";
const SYM_EMPTY = "empty";
const SYM_EQD = "eqDelta";
const SYM_STR = "toString";
const PROPS = new Set([
    SYM_B,
    SYM_C,
    SYM_CV,
    SYM_EMPTY,
    SYM_EQD,
    SYM_L,
    SYM_O,
    SYM_S,
    SYM_STR,
    Symbol.iterator,
]);
const keys = memoize1((size) => [
    ...map(String, range(size)),
    ...PROPS,
]);
/**
 * Wrapper for strided, arbitrary length vectors.
 *
 * @remarks
 * Wraps given buffer in ES6 `Proxy` with custom property
 * getters/setters and implements the following interfaces:
 *
 * - `Iterable` (ES6)
 * - {@link @thi.ng/api#ICopy}
 * - {@link @thi.ng/api#IEmpty}
 * - {@link @thi.ng/api#IEqualsDelta}
 * - {@link IVector}
 * - `Object.toString()`
 *
 * Read/write access for the following properties:
 *
 * - array indices in the [0 .. `size`) interval
 * - `offset` - start index
 * - `stride` - component stride
 * - `buf` - backing buffer (readonly)
 * - `length` - vector size
 *
 * Array index access uses bounds checking against the [0 .. `size`)
 * interval, but, for performance reasons, **not** against the actual
 * wrapped buffer.
 *
 * Note: ES6 proxies are ~10x slower than standard array accesses. If
 * several computations are to be performed on such vectors it will be
 * much more efficient to first copy them to compact arrays and then
 * copy result back if needed.
 *
 * @example
 * ```
 * // 3D vector w/ stride length of 4
 * a = gvec([1,0,0,0,2,0,0,0,3,0,0,0], 3, 0, 4);
 * a[0] // 1
 * a[1] // 2
 * a[2] // 3
 *
 * a.stride
 * // 4
 *
 * [...a]
 * // [1, 2, 3]
 *
 * a.toString()
 * // "[1,2,3]"
 *
 * add([], a, a)
 * // [2, 4, 6]
 *
 * copy(a)
 * // [1, 2, 3]
 *
 * a.copyView()
 * // Proxy [ [ 1, 0, 2, 0, 3, 0 ], ... }
 *
 * eqDelta(a, [1, 2, 3])
 * // true
 * ```
 *
 * @param buf - backing buffer
 * @param size - vector size / num components
 * @param offset - start index
 * @param stride - component stride
 */
const gvec = (buf, size, offset = 0, stride = 1) => new Proxy(buf, {
    get(obj, id) {
        switch (id) {
            case Symbol.iterator:
                return () => stridedValues(obj, size, offset, stride);
            case SYM_L:
                return size;
            case SYM_B:
                return buf;
            case SYM_O:
                return offset;
            case SYM_S:
                return stride;
            case SYM_C:
                return () => setS([], obj, size, 0, offset, 1, stride);
            case SYM_CV:
                return () => gvec(obj, size, offset, stride);
            case SYM_EMPTY:
                return () => zeroes(size);
            case SYM_EQD:
                return (o, eps = EPS) => eqDeltaS(buf, o, size, eps, offset, 0, stride, 1);
            case SYM_STR:
                return () => FORMATTER(stridedValues(obj, size, offset, stride));
            default:
                const j = parseInt(id);
                return !isNaN(j) && j >= 0 && j < size
                    ? obj[offset + j * stride]
                    : undefined;
        }
    },
    set(obj, id, value) {
        const j = parseInt(id);
        if (!isNaN(j) && j >= 0 && j < size) {
            obj[offset + (id | 0) * stride] = value;
        }
        else {
            switch (id) {
                case SYM_O:
                    offset = value;
                    break;
                case SYM_S:
                    stride = value;
                    break;
                case SYM_L:
                    size = value;
                    break;
                default:
                    return false;
            }
        }
        return true;
    },
    has(_, id) {
        return (id >= 0 && id < size) || PROPS.has(id);
    },
    ownKeys() {
        return keys(size);
    },
});

const $$3 = (u, v) => (a, b) => atan2Abs(b[u] - a[u], b[v] - a[v]);
/**
 * Computes direction angle (in radians) of line segment `a` -> `b` in
 * XY plane.
 *
 * @param a -
 * @param b -
 */
const headingSegmentXY = $$3(1, 0);
/**
 * Computes direction angle (in radians) of line segment `a` -> `b` in
 * XZ plane.
 *
 * @param a -
 * @param b -
 */
const headingSegmentXZ = $$3(2, 0);
/**
 * Computes direction angle (in radians) of line segment `a` -> `b` in
 * ZY plane.
 *
 * @param a -
 * @param b -
 */
const headingSegmentYZ = $$3(2, 1);
/**
 * Same as {@link headingSegmentXY}.
 */
const headingSegment = headingSegmentXY;

const [invert, invert2, invert3, invert4] = defOp(([o, a]) => `${o}=1/${a};`);

const [invSqrt, invSqrt2, invSqrt3, invSqrt4] = defOp(([o, a]) => `${o}=1/Math.sqrt(${a});`);

const [isInf, isInf2, isInf3, isInf4] = defFnOp("!isFinite");

const [isNaN$1, isNaN2, isNaN3, isNaN4] = defFnOp("isNaN");

const jitter = (out, a, n = 1, rnd = SYSTEM) => add(out, a, randNorm(new Array(a.length), n, rnd));

/**
 * Limits `v` to max length `n` and writes result to `out` (or to itself if
 * `out` is null).
 *
 * @param out
 * @param v
 * @param n
 */
const limit = (out, v, n) => {
    !out && (out = v);
    const m = mag(v);
    return m > n ? mulN(out, v, n / m) : out !== v ? set(out, v) : out;
};

const [log, log2, log3, log4] = defFnOp("Math.log");

/**
 * Componentwise Math.log2
 */
const [log_2, log_22, log_23, log_24] = defFnOp("Math.log2");

const [logicAnd, logicAnd2, logicAnd3, logicAnd4] = defOp(MATH("&&"));
const [logicAndN, logicAndN2, logicAndN3, logicAndN4] = defOp(MATH_N("&&"), ARGS_VN);

const [logicNot, logicNot2, logicNot3, logicNot4] = defFnOp("!");

const [logicOr, logicOr2, logicOr3, logicOr4] = defOp(MATH("||"));
const [logicOrN, logicOrN2, logicOrN3, logicOrN4] = defOp(MATH_N("||"), ARGS_VN);

const [lshiftI, lshiftI2, lshiftI3, lshiftI4] = defBitOp("<<", true);
const [lshiftU, lshiftU2, lshiftU3, lshiftU4] = defBitOp("<<");
// prettier-ignore
const [lshiftNI, lshiftNI2, lshiftNI3, lshiftNI4] = defBitOpN("<<", true);
const [lshiftNU, lshiftNU2, lshiftNU3, lshiftNU4] = defBitOpN("<<");

const [maddS, maddS2, maddS3, maddS4] = defOpS(MATH2("*", "+"), ARGS_VVV, SARGS_VVV, ARGS_VVV);

const [maddNS, maddNS2, maddNS3, maddNS4] = defOpS(MATH2A_N("*", "+"), ARGS_VNV, SARGS_VV);

const magS = (a, num, ia, sa) => Math.sqrt(dotS(a, a, num, ia, ia, sa, sa));
const magS2 = (a, ia, sa) => Math.sqrt(dotS2(a, a, ia, ia, sa, sa));
const magS3 = (a, ia, sa) => Math.sqrt(dotS3(a, a, ia, ia, sa, sa));
const magS4 = (a, ia, sa) => Math.sqrt(dotS4(a, a, ia, ia, sa, sa));

const magSqS2 = (a, ia, sa) => dotS2(a, a, ia, ia, sa, sa);
const magSqS3 = (a, ia, sa) => dotS3(a, a, ia, ia, sa, sa);
const magSqS4 = (a, ia, sa) => dotS4(a, a, ia, ia, sa, sa);

const abs = Math.abs;
/**
 * Returns index of major component/axis in `v`, i.e. where `|v[i]|` is
 * the largest.
 *
 * @param v -
 */
const major = vop();
major.default((a) => {
    let id = -1;
    let max = -Infinity;
    for (let i = a.length; --i >= 0;) {
        const x = abs(a[i]);
        if (x > max) {
            max = x;
            id = i;
        }
    }
    return id;
});
const major2 = major.add(2, (a) => max2id(abs(a[0]), abs(a[1])));
const major3 = major.add(3, (a) => max3id(abs(a[0]), abs(a[1]), abs(a[2])));
const major4 = major.add(4, (a) => max4id(abs(a[0]), abs(a[1]), abs(a[2]), abs(a[3])));

function mapVectors(fn, out, a, b, c) {
    const num = a.length;
    !out && (out = new Array(num));
    c !== undefined
        ? isNumber(c)
            ? mapVVN$1(fn, out, a, b, c)
            : mapVVV$1(fn, out, a, b, c)
        : isNumber(b)
            ? mapVN$1(fn, out, a, b)
            : mapVV$1(fn, out, a, b);
    return out;
}
const mapVN$1 = (fn, out, a, b) => {
    for (let i = 0, num = a.length; i < num; i++) {
        out[i] = fn(out[i] || [], a[i], b);
    }
};
const mapVV$1 = (fn, out, a, b) => {
    for (let i = 0, num = a.length; i < num; i++) {
        out[i] = fn(out[i] || [], a[i], b[i]);
    }
};
const mapVVN$1 = (fn, out, a, b, c) => {
    for (let i = 0, num = a.length; i < num; i++) {
        out[i] = fn(out[i] || [], a[i], b[i], c);
    }
};
const mapVVV$1 = (fn, out, a, b, c) => {
    for (let i = 0, num = a.length; i < num; i++) {
        out[i] = fn(out[i] || [], a[i], b[i], c[i]);
    }
};

/**
 * Returns new vector of `size` with all components set to `n` (default: 0).
 *
 * @param size -
 * @param n -
 */
const vecOf = (size, n = 0) => new Array(size).fill(n);
/**
 * Returns new one-hot vector of given `size` with `hot` element index (in
 * `[0..size)` range).
 *
 * @remarks
 * Reference: https://en.wikipedia.org/wiki/One-hot
 *
 * @param size -
 * @param hot -
 */
const oneHot = (size, hot) => {
    const res = vecOf(size);
    res[hot] = 1;
    return res;
};

/**
 * Takes an array of vectors and computes componentwise maximum. Writes result
 * to `out` (or a new vector).
 *
 * @param out
 * @param src
 */
const maxBounds = (out, src) => {
    __ensureInputs(src);
    out = out ? setN(out, -Infinity) : vecOf(src[0].length, -Infinity);
    for (let i = src.length; --i >= 0;)
        max(out, out, src[i]);
    return out;
};

/**
 * Takes an array of vectors (of uniform dimensions) and computes the
 * componentwise medians (in accordance to the Manhattan-distance formulation of
 * the k-medians problem). Writes result to `out` (or a new vector).
 *
 * @example
 * ```ts
 * median([], [[3, 10, 400], [4, 30, 100], [1, 40, 200], [2, 20, 300]])
 * // [ 3, 30, 300 ]
 * ```
 *
 * @param out
 * @param src
 */
const median = (out, src) => {
    __ensureInputs(src);
    out = out || [];
    const m = src.length >> 1;
    for (let i = src[0].length; --i >= 0;) {
        out[i] = src.map((x) => x[i]).sort((a, b) => a - b)[m];
    }
    return out;
};
/**
 * Computes the median component of given vector.
 *
 * @example
 * ```ts
 * vmean([10, 20, 5, 15])
 * // 10
 * ```
 *
 * @param a
 */
const vmedian = (a) => {
    a = [...a].sort((a, b) => a - b);
    return a[a.length >> 1];
};

/**
 * Takes an array of vectors and computes componentwise minimum. Writes result
 * to `out` (or a new vector).
 *
 * @param out
 * @param src
 */
const minBounds = (out, src) => {
    __ensureInputs(src);
    out = out ? setN(out, Infinity) : vecOf(src[0].length, Infinity);
    for (let i = src.length; --i >= 0;)
        min(out, out, src[i]);
    return out;
};

const abs$1 = Math.abs;
/**
 * Returns index of minor component/axis in `v`, i.e. where `|v[i]|` is
 * the smallest.
 *
 * @param v -
 */
const minor = vop();
minor.default((a) => {
    let id = -1;
    let min = Infinity;
    for (let i = a.length; --i >= 0;) {
        const x = abs$1(a[i]);
        if (x < min) {
            min = x;
            id = i;
        }
    }
    return id;
});
const minor2 = minor.add(2, (a) => min2id(abs$1(a[0]), abs$1(a[1])));
const minor3 = minor.add(3, (a) => min3id(abs$1(a[0]), abs$1(a[1]), abs$1(a[2])));
const minor4 = minor.add(4, (a) => min4id(abs$1(a[0]), abs$1(a[1]), abs$1(a[2]), abs$1(a[3])));

/**
 * Vector version of {@link @thi.ng/math#mixCubicHermite}.
 *
 * @param out - result
 * @param a -
 * @param ta - tangent A
 * @param b -
 * @param tb - tangent B
 * @param t - interpolation coeff [0..1]
 */
const mixCubicHermite = (out, a, ta, b, tb, t) => {
    const s = t - 1;
    const t2 = t * t;
    const s2 = s * s;
    return addW4(out, a, ta, b, tb, (1 + 2 * t) * s2, t * s2, t2 * (3 - 2 * t), t2 * s);
};
/**
 * Convenience version of {@link mixCubicHermite}, using 4 input points
 * and {@link tangentCardinal} to compute the tangents for points `b`
 * and `c` (with optional `scale`, default 0.5). Interpolated result
 * point is that of `b` and `c`, with `a` and `d` only being used for
 * tangent calculations.
 *
 * If `out` is null, stores result in `b`.
 *
 * @param out - result
 * @param a -
 * @param b -
 * @param c -
 * @param d -
 * @param t - interpolation coeff [0..1]
 * @param scale - tangent tightness / scale
 */
const mixHermiteCardinal = (out, a, b, c, d, t, scale = 0.5) => mixCubicHermite(out, b, tangentCardinal([], a, c, scale), c, tangentCardinal([], b, d, scale), t);
/**
 * Convenience version of {@link mixCubicHermite}, using 4 input points
 * and {@link tangentDiff3} to compute the tangents for points `b` and
 * `c`. Interpolated result point is that of `b` and `c`, with `a` and
 * `d` only being used for tangent calculations.
 *
 * If `out` is null, stores result in `b`.
 *
 * @param out - result
 * @param a -
 * @param b -
 * @param c -
 * @param d -
 * @param t - interpolation coeff [0..1]
 */
const mixHermiteDiff3 = (out, a, b, c, d, t) => mixCubicHermite(out, b, tangentDiff3([], a, b, c), c, tangentDiff3([], b, c, d), t);
/**
 * Vector version of {@link @thi.ng/math#tangentCardinal}.
 *
 * @param out -
 * @param prev -
 * @param next -
 * @param scale -
 * @param ta -
 * @param tc -
 */
const tangentCardinal = (out, prev, next, scale = 0.5, ta = 0, tc = 2) => submN(out, next, prev, scale / (tc - ta));
/**
 * Vector version of {@link @thi.ng/math#tangentDiff3}.
 *
 * @param out - result
 * @param prev -
 * @param curr -
 * @param next -
 * @param ta -
 * @param tb -
 * @param tc -
 */
const tangentDiff3 = (out, prev, curr, next, ta = 0, tb = 1, tc = 2) => addmN(out, submN(out, curr, prev, 1 / (tb - ta)), submN([], next, curr, 1 / (tc - tb)), 0.5);

const [mix$1, mix2, mix3, mix4] = defOp(MIX, ARGS_VVV);

const [mixS, mixS2, mixS3, mixS4] = defOpS(MIX, ARGS_VVV, SARGS_VVV, ARGS_VVV);

const [mixNS, mixNS2, mixNS3, mixNS4] = defOpS(MIX_N, ARGS_VVN, SARGS_VV);

/**
 * Similar to {@link fmod}, {@link remainder}. This version of modulo uses the
 * same logic as in GLSL, yielding different results for negative values, i.e.
 * computes `a - b * floor(a/b)`
 *
 * @remarks
 * **Caution:** Due to the introduction of libc math functions in thi.ng/math
 * v4.0.0 and the resulting name/behavior clashes between the modulo logic in
 * JS, C & GLSL, this function previously _was_ called `fmod`, but going forward
 * has been renamed/swapped to align w/ its GLSL version and now exhibits a
 * different behavior than the current {@link fmod} function.
 *
 * https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mod.xhtml
 */
const [mod, mod2, mod3, mod4] = defHofOp(mod$1, FN2("op"), ARGS_VV);

/**
 * Same as {@link mod}, but 2nd operand is a single scalar (uniform domain for
 * all vector components).
 */
const [modN, modN2, modN3, modN4] = defHofOp(mod$1, FN_N("op"), ARGS_VN, ARGS_V);

/**
 * Returns `out = a * b + c`.
 *
 * - {@link addm}
 * - {@link maddN}
 *
 * @param out -
 * @param a -
 * @param b -
 * @param c -
 */
const [msub, msub2, msub3, msub4] = defOp(MATH2("*", "-"), ARGS_VVV);

/**
 * Returns `out = a * n + b`.
 *
 * @param out - vec
 * @param a - vec
 * @param n - scalar
 * @param b - vec
 */
const [msubN, msubN2, msubN3, msubN4] = defOp(MATH2A_N("*", "-"), ARGS_VNV, ARGS_VV);

const [msubS, msubS2, msubS3, msubS4] = defOpS(MATH2("*", "-"), ARGS_VVV, SARGS_VVV, ARGS_VVV);

const [msubNS, msubNS2, msubNS3, msubNS4] = defOpS(MATH2A_N("*", "-"), ARGS_VNV, SARGS_VV);

const [mulI, mulI2, mulI3, mulI4] = defBitOp("*", true);
const [mulU, mulU2, mulU3, mulU4] = defBitOp("*");
const [mulNI, mulNI2, mulNI3, mulNI4] = defBitOpN("*", true);
const [mulNU, mulNU2, mulNU3, mulNU4] = defBitOpN("*");

const [mulS, mulS2, mulS3, mulS4] = defOpS(MATH("*"));

const [mulNS, mulNS2, mulNS3, mulNS4] = defOpS(MATH_N("*"), ARGS_VN, SARGS_V, ARGS_V);

/**
 * Normalizes strided vector to given (optional) length (default: 1). If `out`
 * is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param n -
 */
const normalizeS = (out, v, num, n = 1, io = 0, ia = 0, so = 1, sa = 1) => {
    !out && (out = v);
    const m = magS(v, num, ia, sa);
    return m >= EPS
        ? mulNS(out, v, n / m, num, io, ia, so, sa)
        : out !== v
            ? setS(out, v, num, io, ia, so, sa)
            : out;
};
/**
 * Normalizes strided 2D vector to given (optional) length (default: 1). If `out`
 * is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param n -
 */
const normalizeS2 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1) => {
    !out && (out = v);
    const m = magS2(v, ia, sa);
    return m >= EPS
        ? mulNS2(out, v, n / m, io, ia, so, sa)
        : out !== v
            ? setS2(out, v, io, ia, so, sa)
            : out;
};
/**
 * Normalizes vector to given (optional) length (default: 1). If `out`
 * is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param n -
 */
const normalizeS3 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1) => {
    !out && (out = v);
    const m = magS3(v, ia, sa);
    return m >= EPS
        ? mulNS3(out, v, n / m, io, ia, so, sa)
        : out !== v
            ? setS3(out, v, io, ia, so, sa)
            : out;
};
/**
 * Normalizes vector to given (optional) length (default: 1). If `out`
 * is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param n -
 */
const normalizeS4 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1) => {
    !out && (out = v);
    const m = magS4(v, ia, sa);
    return m >= EPS
        ? mulNS4(out, v, n / m, io, ia, so, sa)
        : out !== v
            ? setS4(out, v, io, ia, so, sa)
            : out;
};

const [not, not2, not3, not4] = defOp(([o, a]) => `${o}=!${a};`, ARGS_V, ARGS_V, "o", 1, NEW_OUT);

const sqrt = Math.sqrt;
const asin$1 = Math.asin;
const atan2$1 = Math.atan2;
/**
 * Converts cartesian vector `v` to polar coordinates. See {@link cartesian}
 * for reverse operation. If `out` is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 */
const polar = vop(1);
/**
 * Converts 2D cartesian vector `v` to polar coordinates, i.e. `[r,θ]`
 * (angle in radians). See {@link cartesian} for reverse operation. If `out`
 * is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 */
const polar2 = polar.add(2, (out, a) => setC2(out || a, mag(a), atan2$1(a[1], a[0])));
/**
 * Converts 3D cartesian vector `v` to spherical coordinates, i.e.
 * `[r,θ,ϕ]` (angles in radians). See {@link cartesian} for reverse
 * operation. If `out` is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 */
const polar3 = polar.add(3, (out, a) => {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const r = sqrt(x * x + y * y + z * z);
    return setC3(out || a, r, asin$1(z / r), atan2$1(y, x));
});

const [pow, pow2, pow3, pow4] = defOp(FN2("Math.pow"));

/**
 * Returns vector projection of `v` onto `dir`.
 *
 * {@link https://en.wikipedia.org/wiki/Vector_projection}
 *
 * @param v -
 * @param dir -
 */
const project = (out, v, dir) => mulN(out || v, dir, dot(v, dir) / magSq(dir));

/**
 * Randomizes `v` with each component in interval `[n..m)`. If no `rnd`
 * instance is given, uses {@link @thi.ng/random#SYSTEM}, i.e.
 * `Math.random`.
 *
 * @param v -
 * @param n - default -1
 * @param m - default 1
 * @param rnd -
 * @param ia -
 * @param sa -
 */
const [randomS, randomS2, randomS3, randomS4] = defHofOpS(SYSTEM, ([a]) => `${a}=rnd.minmax(n,m);`, "a", "n=-1,m=1,rnd=op,ia=0,sa=1", "a", "a", NEW_OUT_A);
const [randomDistribS, randomDistribS2, randomDistribS3, randomDistribS4,] = defHofOpS(normal, ([a]) => `${a}=rnd()*n;`, "a", "rnd=op(),n=1,ia=0,sa=1", "a", "a", NEW_OUT_A);
const $norm = (normalize, random) => (a, n = 1, rnd, ia = 0, sa = 1) => normalize(null, random(a, -1, 1, rnd, ia, sa), n, ia, ia, sa, sa);
const $normDist = (normalize, random) => (a, rnd, n = 1, ia = 0, sa = 1) => normalize(null, random(a, rnd, 1, ia, sa), n, ia, ia, sa, sa);
/**
 * Sets `v` to random strided vector, normalized to length `n` (default: 1). If
 * no `rnd` instance is given, uses {@link @thi.ng/random#SYSTEM}, i.e.
 * `Math.random`.
 *
 * @param v -
 * @param num -
 * @param n -
 * @param rnd -
 * @param ia -
 * @param sa -
 */
const randNormS = (a, num, n = 1, rnd, ia = 0, sa = 1) => normalizeS((a = randomS(a, num, -1, 1, rnd, ia, sa)), a, num, n, ia, ia, sa, sa);
const randNormS2 = $norm(normalizeS2, randomS2);
const randNormS3 = $norm(normalizeS3, randomS3);
const randNormS4 = $norm(normalizeS4, randomS4);
const randNormDistribS = (a, num, rnd, n = 1, ia = 0, sa = 1) => normalizeS(null, randomDistribS(a, num, rnd, 1, ia, sa), num, n, ia, ia, sa, sa);
const randNormDistribS2 = $normDist(normalizeS2, randomDistribS2);
const randNormDistribS3 = $normDist(normalizeS3, randomDistribS3);
const randNormDistribS4 = $normDist(normalizeS4, randomDistribS4);
/**
 * Sets `out` to random vector with each component in the semi-open
 * interval defined by [min,max).
 *
 * @param out -
 * @param min -
 * @param max -
 * @param rnd -
 */
const [randMinMaxS, randMinMaxS2, randMinMaxS3, randMinMaxS4] = defHofOpS(SYSTEM, ([o, a, b]) => `${o}=rnd.minmax(${a},${b});`, "o,a,b", `rnd=op,${SARGS_VV}`, "o,a,b");

const reflect = (out, a, b) => maddN(out || a, b, -2 * dot(a, b), a);

const refract = (out, a, n, eta) => {
    !out && (out = a);
    const d = dot(a, n);
    const k = 1 - eta * eta * (1 - d * d);
    return k < 0
        ? zero(out)
        : maddN(out, n, -(eta * d + Math.sqrt(k)), mulN(out, a, eta));
};

/**
 * This version of mod uses the same logic as the standard C function
 * `remainder()` (or its equivavalent in the thi.ng/maths package), i.e.
 * componentwise `a - b * round(a / b)`.
 *
 * @remarks
 * Also see {@link @thi.ng/math#remainder}.
 */
const [remainder, remainder2, remainder3, remainder4] = defHofOp(remainder$1, FN2("op"), ARGS_VV);

/**
 * Same as {@link remainder}, but 2nd operand is a single scalar (uniform domain
 * for all vector components).
 */
const [remainderN, remainderN2, remainderN3, remainderN4] = defHofOp(remainder$1, FN_N("op"), ARGS_VN, ARGS_V);

const rotateAroundAxis3 = (out, v, axis, theta) => {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    const ax = axis[0];
    const ay = axis[1];
    const az = axis[2];
    const ux = ax * x;
    const uy = ax * y;
    const uz = ax * z;
    const vx = ay * x;
    const vy = ay * y;
    const vz = ay * z;
    const wx = az * x;
    const wy = az * y;
    const wz = az * z;
    const uvw = ux + vy + wz;
    const s = Math.sin(theta);
    const c = Math.cos(theta);
    return setC3(out || v, ax * uvw +
        (x * (ay * ay + az * az) - ax * (vy + wz)) * c +
        (-wy + vz) * s, ay * uvw +
        (y * (ax * ax + az * az) - ay * (ux + wz)) * c +
        (wx - uz) * s, az * uvw +
        (z * (ax * ax + ay * ay) - az * (ux + vy)) * c +
        (-vx + uy) * s);
};

const rotateAroundPoint2 = (out, v, p, theta) => {
    const x = v[0] - p[0];
    const y = v[1] - p[1];
    const s = Math.sin(theta);
    const c = Math.cos(theta);
    return setC2(out || v, x * c - y * s + p[0], x * s + y * c + p[1]);
};

const _rotate = (set, u, v) => (out, a, theta, io = 0, ia = 0, so = 1, sa = 1) => {
    out ? out !== a && set(out, a, io, ia, so, sa) : (out = a);
    const s = Math.sin(theta);
    const c = Math.cos(theta);
    const x = a[ia + u * sa];
    const y = a[ia + v * sa];
    out[io + u * so] = x * c - y * s;
    out[io + v * so] = x * s + y * c;
    return out;
};
const rotateS2 = _rotate(setS2, 0, 1);
const rotateXS3 = _rotate(setS3, 1, 2);
const rotateYS3 = _rotate(setS3, 2, 0);
const rotateZS3 = _rotate(setS3, 0, 1);

/**
 * Rounds components of the first input to multiples of the 2nd input vector.
 *
 * @remarks
 * Unitl v4.8.0 errorneously defined what should have been {@link roundN}. Now
 * correctly using 2 input vectors.
 */
const [round, round2, round3, round4] = defHofOp(roundTo, FN2("op"), ARGS_VV);
/**
 * Similar to {@link round}, but only uses a single scalar to round all vector
 * components.
 */
const [roundN, roundN2, roundN3, roundN4] = defHofOp(roundTo, FN_N("op"), "o,a,n=1", "o,a");

const [rshiftI, rshiftI2, rshiftI3, rshiftI4] = defBitOp(">>", true);
const [rshiftU, rshiftU2, rshiftU3, rshiftU4] = defBitOp(">>>");
// prettier-ignore
const [rshiftNI, rshiftNI2, rshiftNI3, rshiftNI4] = defBitOpN(">>", true);
const [rshiftNU, rshiftNU2, rshiftNU3, rshiftNU4] = defBitOpN(">>>");

/**
 * Componentwise application of {@link @thi.ng/math#safeDiv}.
 *
 * @param out -
 * @param a -
 * @param b -
 */
const [safeDiv, safeDiv2, safeDiv3, safeDiv4] = defHofOp(safeDiv$1, FN2("op"), ARGS_VV);

const [setNS, setNS2, setNS3, setNS4] = defOpS(SET_N, "o,n", "io=0,so=1", "o", "o", "");

/**
 * Sets `out` to `[a.x, a.y, n]`
 *
 * @param out -
 * @param a -
 * @param n -
 */
const setVN3 = (out, a, n) => setC3(out, a[0], a[1], n);
/**
 * Sets `out` to `[a.x, a.y, a.z, n]`
 *
 * @param out -
 * @param a -
 * @param n -
 */
const setVN4 = (out, a, n) => setC4(out, a[0], a[1], a[2], n);

const [sign, sign2, sign3, sign4] = defFnOp("Math.sign");

/**
 * Returns 6x the signed volume of the tetrahedron defined by given 3D points.
 *
 * @remarks
 * Returns positive or negative value if `d` lies below/above the plane defined
 * by a,b,c respectively (where "below" is defined such that a,b,c are
 * counterclockwise if viewed from above). Returns zero if all points are
 * coplanar.
 *
 * Based on code by Jonathan R. Shewchuk
 * http://www.cs.cmu.edu/afs/cs/project/quake/public/code/predicates.c
 *
 * @param a
 * @param b
 * @param c
 * @param d
 */
const signedVolume = (a, b, c, [dx, dy, dz]) => {
    const ady = a[1] - dy;
    const bdy = b[1] - dy;
    const cdy = c[1] - dy;
    const adz = a[2] - dz;
    const bdz = b[2] - dz;
    const cdz = c[2] - dz;
    return ((a[0] - dx) * (bdy * cdz - bdz * cdy) +
        (b[0] - dx) * (cdy * adz - cdz * ady) +
        (c[0] - dx) * (ady * bdz - adz * bdy));
};

const [sin, sin2, sin3, sin4] = defFnOp("Math.sin");

const [sinh, sinh2, sinh3, sinh4] = defFnOp("Math.sinh");

/**
 * Computes softmax (aka normalized exp) of input vector `src` and writes
 * results to `out` (or if null, back into `src`).
 *
 * @remarks
 * Computes elementwise: `s[i] = exp(src[i]) / sum(exp(src))`. The result
 * vector's elements will sum to 1.0.
 *
 * This function is often used as the last activation function in a neural
 * network to normalize the output to a probability distribution over predicted
 * output classes.
 *
 * References:
 * - https://en.wikipedia.org/wiki/Softmax_function
 * - https://victorzhou.com/blog/softmax/
 *
 * @param out
 * @param src
 */
const softMax = (out, src) => {
    const e = exp([], src);
    return divN(out || src, e, sum(e));
};

/**
 * Returns returns true if at least one vector component in `v` is
 * truthy.
 *
 * @param v -
 */
const some = vop();
some.default((v) => {
    for (let i = v.length; --i >= 0;) {
        if (v[i])
            return true;
    }
    return false;
});
const some2 = some.add(2, (a) => a[0] || a[1]);
const some3 = some.add(3, (a) => a[0] || a[1] || a[2]);
const some4 = some.add(4, (a) => a[0] || a[1] || a[2] || a[3]);

const [sqrt$1, sqrt2, sqrt3, sqrt4] = defFnOp("Math.sqrt");

/**
 * Like GLSL `step()`
 *
 * @param out -
 * @param e -
 * @param v -
 */
const [step, step2, step3, step4] = defHofOp(step$1, FN2("op"), "o,e,a", undefined, "o", 2, DEFAULT_OUT);

/**
 * Like GLSL `smoothstep()`
 *
 * @param out -
 * @param e1 -
 * @param e2 -
 * @param v -
 */
const [smoothStep, smoothStep2, smoothStep3, smoothStep4] = defHofOp(smoothStep$1, FN3(), "o,e1,e2,a", undefined, "o", 3, DEFAULT_OUT);

/**
 * Returns standardized version of `a`, i.e. `a' / sd(a')`, where `a'` is the
 * {@link center}'ed version of `a`.
 *
 * @remarks
 * If `mag(a')` is zero, the returned vector will have all components
 * zero-valued too.
 *
 * @param out
 * @param a
 */
const standardize = (out, a) => {
    out = center(out, a);
    const m = magSq(out);
    return m > 0 ? mulN(null, out, 1 / Math.sqrt(m / (out.length - 1))) : out;
};

const [subI, subI2, subI3, subI4] = defBitOp("-", true);
const [subU, subU2, subU3, subU4] = defBitOp("-");
const [subNI, subNI2, subNI3, subNI4] = defBitOpN("-", true);
const [subNU, subNU2, subNU3, subNU4] = defBitOpN("-");

/**
 * Returns `out = (a - b) * c`.
 *
 * - {@link madd}
 * - {@link addm}
 */
const [subm, subm2, subm3, subm4] = defOp(MATH2("-", "*"), ARGS_VVV);

const [submS, submS2, submS3, submS4] = defOpS(MATH2("-", "*"), ARGS_VVV, SARGS_VVV, ARGS_VVV);

const [submNS, submNS2, submNS3, submNS4] = defOpS(MATH2_N("-", "*"), ARGS_VVN, SARGS_VV);

const [subS, subS2, subS3, subS4] = defOpS(MATH("-"));

const [subNS, subNS2, subNS3, subNS4] = defOpS(MATH_N("-"), ARGS_VN, SARGS_V, ARGS_V);

/**
 * Places a re-ordered 2D version of vector `a` into `out`. The given
 * coord indices must be valid for `a`. No bounds checking.
 *
 * @param out -
 * @param a -
 * @param x - new x coord index
 * @param y - new y coord index
 */
const swizzle2 = (out, a, x, y) => setC2(out || a, a[x] || 0, a[y] || 0);
/**
 * Places a re-ordered 3D version of vector `a` into `out`. The given
 * coord indices must be valid for `a`. No bounds checking.
 *
 * @param out -
 * @param a -
 * @param x - new x coord index
 * @param y - new y coord index
 * @param z - new z coord index
 */
const swizzle3 = (out, a, x, y, z) => setC3(out || a, a[x] || 0, a[y] || 0, a[z] || 0);
/**
 * Places a re-ordered 4D version of vector `a` into `out`. The given
 * coord indices must be valid for `a`. No bounds checking.
 *
 * @param out -
 * @param a -
 * @param x - new x coord index
 * @param y - new y coord index
 * @param z - new z coord index
 * @param w - new w coord index
 */
const swizzle4 = (out, a, x, y, z, w) => setC4(out || a, a[x] || 0, a[y] || 0, a[z] || 0, a[w] || 0);
const swapXY = (out, v) => swizzle3(out, v, 1, 0, 2);
const swapXZ = (out, v) => swizzle3(out, v, 2, 1, 0);
const swapYZ = (out, v) => swizzle3(out, v, 0, 2, 1);
/**
 * Sets `out[a] = n`, returns `out`.
 *
 * @param out -
 * @param n -
 * @param a -
 */
const setSwizzle1 = (out, n, a) => ((out[a] = n), out);
/**
 * Sets `out[a] = v.x, out[b] = v.y`, returns `out`.
 *
 * @param out -
 * @param v -
 * @param a -
 * @param b -
 */
const setSwizzle2 = (out, v, a, b) => (((out[a] = v[0]), (out[b] = v[1])), out);
/**
 * Sets `out[a] = v.x, out[b] = v.y, out[c] = v.z`, returns `out`.
 *
 * @param out -
 * @param v -
 * @param a -
 * @param b -
 * @param c -
 */
const setSwizzle3 = (out, v, a, b, c) => (((out[a] = v[0]), (out[b] = v[1]), (out[c] = v[2])), out);
/**
 * Sets `out[a] = v.x, out[b] = v.y, out[c] = v.z, out[d]=v.w`, returns `out`.
 *
 * @param out -
 * @param v -
 * @param a -
 * @param b -
 * @param c -
 * @param d -
 */
const setSwizzle4 = (out, v, a, b, c, d) => (((out[a] = v[0]), (out[b] = v[1]), (out[c] = v[2]), (out[d] = v[3])), out);

const [tan, tan2, tan3, tan4] = defFnOp("Math.tan");

const [tanh, tanh2, tanh3, tanh4] = defFnOp("Math.tanh");

/**
 * Computes tensor product (aka outer product) of `a` and `b` and writes result
 * to `out` (or creates a new array if null). The result is to be interpreted as
 * a matrix (in column-major order) of `a.length` rows and `b.length` columns.
 *
 * @remarks
 * The tensor product is not commutative, i.e. `tensor(a,b) != tensor(b,a)`. The
 * latter case results in the Kronecker product and can be understood as
 * vectorization of `tensor(a,b)`.
 *
 * The Dot product (aka inner product) of `a` and `b` is the matrix trace of the
 * tensor/outer product.
 *
 * References:
 *
 * - https://en.wikipedia.org/wiki/Outer_product
 * - https://en.wikipedia.org/wiki/Outer_product#Connection_with_the_Kronecker_product
 *
 * @example
 * ```ts
 * tensor([], [1, 2, 3], [4, 5])
 * // [ 4, 8, 12, 5, 10, 15 ]
 *
 * tensorProduct([], [4, 5], [1, 2, 3])
 * // [ 4, 5, 8, 10, 12, 15 ]
 * ```
 *
 * @param out
 * @param a
 * @param b
 */
const tensor = (out, a, b) => {
    out = out || [];
    const n = a.length;
    const m = b.length;
    for (let i = 0, k = 0; i < m; i++) {
        const bb = b[i];
        for (let j = 0; j < n; j++) {
            out[k++] = a[j] * bb;
        }
    }
    return out;
};

const [trunc, trunc2, trunc3, trunc4] = defFnOp("Math.trunc");

const variance = (a) => magSq(center([], a)) / (a.length - 1);
const sd = (a) => Math.sqrt(variance(a));

const [wrap, wrap2, wrap3, wrap4] = defHofOp(wrap$1, FN3(), ARGS_VVV);

const [eq, eq2, eq3, eq4] = defOp(MATH("==="));

const [neq, neq2, neq3, neq4] = defOp(MATH("!=="));

const [gt, gt2, gt3, gt4] = defOp(MATH(">"));

const [gte, gte2, gte3, gte4] = defOp(MATH(">="));

const [lt, lt2, lt3, lt4] = defOp(MATH("<"));

const [lte, lte2, lte3, lte4] = defOp(MATH("<="));

export { AVec, FORMATTER, Vec2, Vec3, Vec4, acos, acos2, acos3, acos4, addI, addI2, addI3, addI4, addNI, addNI2, addNI3, addNI4, addNS, addNS2, addNS3, addNS4, addNU, addNU2, addNU3, addNU4, addS, addS2, addS3, addS4, addU, addU2, addU3, addU4, addm, addm2, addm3, addm4, addmNS, addmNS2, addmNS3, addmNS4, addmS, addmS2, addmS3, addmS4, asBVec, asBVec2, asBVec3, asBVec4, asIVec, asIVec2, asIVec3, asIVec4, asUVec, asUVec2, asUVec3, asUVec4, asVec2, asVec3, asVec4, asin, asin2, asin3, asin4, atan, atan2, atan3, atan4, atan_2, atan_22, atan_23, atan_24, bitAndI, bitAndI2, bitAndI3, bitAndI4, bitAndNI, bitAndNI2, bitAndNI3, bitAndNI4, bitAndNU, bitAndNU2, bitAndNU3, bitAndNU4, bitAndU, bitAndU2, bitAndU3, bitAndU4, bitNotI, bitNotI2, bitNotI3, bitNotI4, bitNotU, bitNotU2, bitNotU3, bitNotU4, bitOrI, bitOrI2, bitOrI3, bitOrI4, bitOrNI, bitOrNI2, bitOrNI3, bitOrNI4, bitOrNU, bitOrNU2, bitOrNU3, bitOrNU4, bitOrU, bitOrU2, bitOrU3, bitOrU4, bitXorI, bitXorI2, bitXorI3, bitXorI4, bitXorNI, bitXorNI2, bitXorNI3, bitXorNI4, bitXorNU, bitXorNU2, bitXorNU3, bitXorNU4, bitXorU, bitXorU2, bitXorU3, bitXorU4, ceil, ceil2, ceil3, ceil4, center, clamp, clamp01, clamp01_2, clamp01_3, clamp01_4, clamp11, clamp11_2, clamp11_3, clamp11_4, clamp2, clamp3, clamp4, clampN, clampN2, clampN3, clampN4, comparator2, comparator3, comparator4, correlation, cos, cos2, cos3, cos4, cosh, cosh2, cosh3, cosh4, covariance, crossS2, crossS3, declareIndex, declareIndices, defFormat, degrees, degrees2, degrees3, degrees4, distBrayCurtis, distCanberra, distChebyshev, distChebyshev2, distChebyshev3, distChebyshev4, distHamming, distHaversine, distHaversineLatLon, distHaversineLonLat, distJaccard, distManhattan, distManhattan2, distManhattan3, distManhattan4, distMinkowski, distSorensenDice, divI, divI2, divI3, divI4, divNI, divNI2, divNI3, divNI4, divNS, divNS2, divNS3, divNS4, divNU, divNU2, divNU3, divNU4, divS, divS2, divS3, divS4, divU, divU2, divU3, divU4, eq, eq2, eq3, eq4, equals, equals2, equals3, equals4, every, every2, every3, every4, exp, exp2, exp3, exp4, exp_2, exp_22, exp_23, exp_24, faceForward, fill, fit, fit01, fit01_2, fit01_3, fit01_4, fit11, fit11_2, fit11_3, fit11_4, fit2, fit3, fit4, floor, floor2, floor3, floor4, fmod, fmod2, fmod3, fmod4, fmodN, fmodN2, fmodN3, fmodN4, fract, fract2, fract3, fract4, fromBVec, fromBVec2, fromBVec3, fromBVec4, gt, gt2, gt3, gt4, gte, gte2, gte3, gte4, gvec, hash, headingSegment, headingSegmentXY, headingSegmentXZ, headingSegmentYZ, intoBuffer, intoStridedBuffer, invSqrt, invSqrt2, invSqrt3, invSqrt4, invert, invert2, invert3, invert4, isInf, isInf2, isInf3, isInf4, isNaN$1 as isNaN, isNaN2, isNaN3, isNaN4, jitter, limit, log, log2, log3, log4, log_2, log_22, log_23, log_24, logicAnd, logicAnd2, logicAnd3, logicAnd4, logicAndN, logicAndN2, logicAndN3, logicAndN4, logicNot, logicNot2, logicNot3, logicNot4, logicOr, logicOr2, logicOr3, logicOr4, logicOrN, logicOrN2, logicOrN3, logicOrN4, lshiftI, lshiftI2, lshiftI3, lshiftI4, lshiftNI, lshiftNI2, lshiftNI3, lshiftNI4, lshiftNU, lshiftNU2, lshiftNU3, lshiftNU4, lshiftU, lshiftU2, lshiftU3, lshiftU4, lt, lt2, lt3, lt4, lte, lte2, lte3, lte4, maddNS, maddNS2, maddNS3, maddNS4, maddS, maddS2, maddS3, maddS4, magS, magS2, magS3, magS4, magSqS2, magSqS3, magSqS4, major, major2, major3, major4, mapBuffer, mapStridedBuffer, mapV, mapVN, mapVV, mapVVN, mapVVV, mapVectors, maxBounds, mean, median, minBounds, minor, minor2, minor3, minor4, mix$1 as mix, mix2, mix3, mix4, mixCubicHermite, mixHermiteCardinal, mixHermiteDiff3, mixNS, mixNS2, mixNS3, mixNS4, mixS, mixS2, mixS3, mixS4, mod, mod2, mod3, mod4, modN, modN2, modN3, modN4, msub, msub2, msub3, msub4, msubN, msubN2, msubN3, msubN4, msubNS, msubNS2, msubNS3, msubNS4, msubS, msubS2, msubS3, msubS4, mulI, mulI2, mulI3, mulI4, mulNI, mulNI2, mulNI3, mulNI4, mulNS, mulNS2, mulNS3, mulNS4, mulNU, mulNU2, mulNU3, mulNU4, mulS, mulS2, mulS3, mulS4, mulU, mulU2, mulU3, mulU4, neq, neq2, neq3, neq4, normalizeS, normalizeS2, normalizeS3, normalizeS4, not, not2, not3, not4, oneHot, polar, polar2, polar3, pow, pow2, pow3, pow4, project, radians, radians2, radians3, radians4, randMinMaxS, randMinMaxS2, randMinMaxS3, randMinMaxS4, randNormDistribS, randNormDistribS2, randNormDistribS3, randNormDistribS4, randNormS, randNormS2, randNormS3, randNormS4, randomDistribS, randomDistribS2, randomDistribS3, randomDistribS4, randomS, randomS2, randomS3, randomS4, reflect, refract, remainder, remainder2, remainder3, remainder4, remainderN, remainderN2, remainderN3, remainderN4, rotateAroundAxis3, rotateAroundPoint2, rotateS2, rotateXS3, rotateYS3, rotateZS3, round, round2, round3, round4, roundN, roundN2, roundN3, roundN4, rshiftI, rshiftI2, rshiftI3, rshiftI4, rshiftNI, rshiftNI2, rshiftNI3, rshiftNI4, rshiftNU, rshiftNU2, rshiftNU3, rshiftNU4, rshiftU, rshiftU2, rshiftU3, rshiftU4, safeDiv, safeDiv2, safeDiv3, safeDiv4, sd, setCS2, setCS3, setCS4, setFormat, setNS, setNS2, setNS3, setNS4, setSwizzle1, setSwizzle2, setSwizzle3, setSwizzle4, setVN3, setVN4, sign, sign2, sign3, sign4, signedVolume, sin, sin2, sin3, sin4, sinh, sinh2, sinh3, sinh4, smoothStep, smoothStep2, smoothStep3, smoothStep4, softMax, some, some2, some3, some4, sqrt$1 as sqrt, sqrt2, sqrt3, sqrt4, standardize, step, step2, step3, step4, stridedValues, subI, subI2, subI3, subI4, subNI, subNI2, subNI3, subNI4, subNS, subNS2, subNS3, subNS4, subNU, subNU2, subNU3, subNU4, subS, subS2, subS3, subS4, subU, subU2, subU3, subU4, subm, subm2, subm3, subm4, submNS, submNS2, submNS3, submNS4, submS, submS2, submS3, submS4, swapXY, swapXZ, swapYZ, swizzle2, swizzle3, swizzle4, tan, tan2, tan3, tan4, tangentCardinal, tangentDiff3, tanh, tanh2, tanh3, tanh4, tensor, trunc, trunc2, trunc3, trunc4, variance, vec2, vec2n, vec3, vec3n, vec4, vec4n, vecIterator, vecOf, vmean, vmedian, weightedDistance, wrap, wrap2, wrap3, wrap4 };

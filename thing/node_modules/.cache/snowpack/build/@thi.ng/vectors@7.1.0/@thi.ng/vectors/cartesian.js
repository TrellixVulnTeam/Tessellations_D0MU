import { cossin } from '@thi.ng/math/angle';
import { ZERO2, ZERO3 } from './api.js';
import { vop } from './vop.js';
import { maddN2 } from './maddn.js';
import { setC3 } from './setc.js';
import '@thi.ng/errors/unsupported';
import './compile/emit.js';
import '@thi.ng/transducers/comp';
import '@thi.ng/transducers/map';
import '@thi.ng/transducers/map-indexed';
import '@thi.ng/transducers/range';
import '@thi.ng/transducers/str';
import '@thi.ng/transducers/take';
import '@thi.ng/transducers/transduce';
import '@thi.ng/transducers/zip';
import './compile/templates.js';

const cos = Math.cos;
const sin = Math.sin;
/**
 * Converts polar vector `v` to cartesian coordinates and adds optional
 * `offset`. See {@link polar} for reverse operation. If `out` is null,
 * modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param offset -
 */
const cartesian = vop(1);
/**
 * Converts 2D polar vector `v` to cartesian coordinates and adds
 * optional `offset`. See {@link polar} for reverse operation. If `out` is
 * null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param offset -
 */
const cartesian2 = cartesian.add(2, (out, a, b = ZERO2) => maddN2(out || a, cossin(a[1]), a[0], b));
/**
 * Converts 3D polar vector `v` to cartesian coordinates and adds
 * optional `offset`. See {@link polar} for reverse operation. If `out` is
 * null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param offset -
 */
const cartesian3 = cartesian.add(3, (out, a, b = ZERO3) => {
    const r = a[0];
    const theta = a[1];
    const phi = a[2];
    const ct = cos(theta);
    return setC3(out || a, r * ct * cos(phi) + b[0], r * ct * sin(phi) + b[1], r * sin(theta) + b[2]);
});

export { cartesian, cartesian2, cartesian3 };

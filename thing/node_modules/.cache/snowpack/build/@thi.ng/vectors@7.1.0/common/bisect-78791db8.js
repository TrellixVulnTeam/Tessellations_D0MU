import { HALF_PI, PI } from '@thi.ng/math/api';
import { addmN } from '../@thi.ng/vectors/addmn.js';
import { direction } from '../@thi.ng/vectors/direction.js';
import { atan2Abs } from '@thi.ng/math/angle';
import { mixN2 } from '../@thi.ng/vectors/mixn.js';
import { normalize } from '../@thi.ng/vectors/normalize.js';
import { perpendicularCCW } from '../@thi.ng/vectors/perpendicular.js';
import { sub } from '../@thi.ng/vectors/sub.js';

/**
 * Returns orientation angle (in radians) of vector `a` in XY plane.
 *
 * @param a -
 */
const headingXY = (a) => atan2Abs(a[1], a[0]);
/**
 * Returns orientation angle (in radians) of vector `a` in XZ plane.
 *
 * @param a -
 */
const headingXZ = (a) => atan2Abs(a[2], a[0]);
/**
 * Returns orientation angle (in radians) of vector `a` in ZY plane.
 *
 * @param a -
 */
const headingYZ = (a) => atan2Abs(a[2], a[1]);
/**
 * Same as {@link headingXY}
 */
const heading = headingXY;

const bisect2 = (a, b) => {
    const theta = (headingXY(a) + headingXY(b)) / 2;
    return theta <= HALF_PI ? theta : PI - theta;
};
/**
 * Returns normalized bisector vector for point `b` in the triangle `a`
 * -> `b` -> `c`. If `out` is null, creates a new result vector. The `n`
 * arg can be used to scale the result vector to given length (default:
 * 1).
 *
 * @param out -
 * @param a -
 * @param b -
 * @param c -
 * @param n -
 */
const cornerBisector = (out, a, b, c, n = 1) => (!out && (out = []),
    normalize(out, addmN(out, normalize(out, sub(out, a, b)), normalize(null, sub([], c, b)), 0.5), n));
/**
 * 2D version of {@link cornerBisector} which doesn't always bisect the
 * smaller/inside angle, but also doesn't suffer sign/orientation
 * flipping of returned bisector vector.
 *
 * @remarks
 * Instead, the direction of the result is dependent on the orientation
 * of the input triangle. If `a`, `b`, `c` are in CW order, the result
 * will point away from the triangle's centroid. If CCW, the result will
 * point towards the inside.
 *
 * @param out -
 * @param a -
 * @param b -
 * @param c -
 * @param n -
 */
const cornerBisector2 = (out, a, b, c, n = 1) => (!out && (out = []),
    perpendicularCCW(out, normalize(out, mixN2(out, direction(out, a, b), direction([], b, c), 0.5), n)));

export { cornerBisector2 as a, bisect2 as b, cornerBisector as c, headingXZ as d, headingYZ as e, heading as f, headingXY as h };

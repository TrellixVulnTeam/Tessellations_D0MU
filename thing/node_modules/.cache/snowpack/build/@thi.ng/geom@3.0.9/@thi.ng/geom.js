import { isNumber } from '@thi.ng/checks/is-number';
import { add3, add2, add } from '@thi.ng/vectors/add';
import { set, set2, set3 } from '@thi.ng/vectors/set';
import { _ as __copyAttribs, a as __copyShape } from '../common/copy-83b50873.js';
import { A as APC, _ as __dispatch, a as asPolygon, P as Polygon, v as vertices, e as ensureVertices, b as __dispatch2 } from '../common/as-polygon-1201fa10.js';
export { A as APC, P as Polygon, a as asPolygon, e as ensureVertices, v as vertices } from '../common/as-polygon-1201fa10.js';
import { equiv } from '@thi.ng/equiv';
import { pointAt as pointAt$1, pointAtTheta } from '@thi.ng/geom-arc/point-at';
import { _ as __argsVV, a as __argAttribs, C as Circle } from '../common/circle-874bc0da.js';
export { C as Circle, c as circle, b as circleFrom2Points, d as circleFrom3Points } from '../common/circle-874bc0da.js';
import { illegalState } from '@thi.ng/errors/illegal-state';
import { copy, copyVectors } from '@thi.ng/vectors/copy';
import { maddN2, maddN } from '@thi.ng/vectors/maddn';
import { SQRT2_2, TAU, SQRT3, PI, EPS, HALF_PI } from '@thi.ng/math/api';
import { ZERO3, Z3, ZERO2, MAX2, MIN2, MAX3, MIN3 } from '@thi.ng/vectors/api';
import { max3, max2, max } from '@thi.ng/vectors/max';
import { min3, min2, min } from '@thi.ng/vectors/min';
import { sub3, sub2, sub } from '@thi.ng/vectors/sub';
import { subN3, subN2 } from '@thi.ng/vectors/subn';
import { fromEndPoints } from '@thi.ng/geom-arc/from-endpoints';
import { cubicFromArc as cubicFromArc$1 } from '@thi.ng/geom-splines/cubic-arc';
import { cubicFromLine as cubicFromLine$1 } from '@thi.ng/geom-splines/cubic-line';
import { cubicFromQuadratic as cubicFromQuadratic$1 } from '@thi.ng/geom-splines/cubic-quadratic';
import { liangBarsky2 } from '@thi.ng/geom-clip-line/liang-barsky';
import { map } from '@thi.ng/transducers/map';
import { mapcat } from '@thi.ng/transducers/mapcat';
import { defmulti, DEFAULT } from '@thi.ng/defmulti/defmulti';
import { openCubicFromBreakPoints, closedCubicFromBreakPoints } from '@thi.ng/geom-splines/cubic-from-breakpoints';
import { openCubicFromControlPoints, closedCubicFromControlPoints } from '@thi.ng/geom-splines/cubic-from-controlpoints';
import { peek } from '@thi.ng/arrays/peek';
import { eqDelta } from '@thi.ng/math/eqdelta';
import { mulN2, mulN } from '@thi.ng/vectors/muln';
import { zeroes } from '@thi.ng/vectors/setn';
import { rad, cossin } from '@thi.ng/math/angle';
import { WS } from '@thi.ng/strings/groups';
import { dot3, dot } from '@thi.ng/vectors/dot';
import { normalize } from '@thi.ng/vectors/normalize';
import { orthoNormal3 } from '@thi.ng/vectors/ortho-normal';
import { cycle } from '@thi.ng/transducers/cycle';
import { normRange } from '@thi.ng/transducers/norm-range';
import { push } from '@thi.ng/transducers/push';
import { transduce } from '@thi.ng/transducers/transduce';
import { zip } from '@thi.ng/transducers/zip';
import { cartesian2 } from '@thi.ng/vectors/cartesian';
import { closestPointPlane } from '@thi.ng/geom-closest-point/plane';
import { alignmentQuat } from '@thi.ng/matrices/alignment-quat';
import { mulVQ, mulV344, mulV } from '@thi.ng/matrices/mulv';
import { quadraticFromLine as quadraticFromLine$1 } from '@thi.ng/geom-splines/quadratic-line';
import { centroid as centroid$1 } from '@thi.ng/geom-poly-utils/centroid';
import { dist } from '@thi.ng/vectors/dist';
import { equilateralTriangle2 } from '@thi.ng/geom-poly-utils/equilateral';
import { perimeter } from '@thi.ng/geom-poly-utils/perimeter';
import { polyArea2 } from '@thi.ng/geom-poly-utils/area';
import { signedArea2 } from '@thi.ng/vectors/signed-area';
import { convertTree } from '@thi.ng/hiccup-svg/convert';
import { ff } from '@thi.ng/hiccup-svg/format';
import { svg } from '@thi.ng/hiccup-svg/svg';
import { serialize } from '@thi.ng/hiccup/serialize';
import { bounds as bounds$1 } from '@thi.ng/geom-arc/bounds';
import { bounds as bounds$2 } from '@thi.ng/geom-poly-utils/bounds';
import { cubicBounds } from '@thi.ng/geom-splines/cubic-bounds';
import { quadraticBounds } from '@thi.ng/geom-splines/quadratic-bounds';
import { comp } from '@thi.ng/transducers/comp';
import { filter } from '@thi.ng/transducers/filter';
import { iterator1 } from '@thi.ng/transducers/iterator';
import { mul2 } from '@thi.ng/vectors/mul';
import { submN } from '@thi.ng/vectors/submn';
import { centerOfWeight2 } from '@thi.ng/geom-poly-utils/center-of-weight';
import { divN } from '@thi.ng/vectors/divn';
import { mixN, mixN2 } from '@thi.ng/vectors/mixn';
import { classifyPointInCircle, classifyPointInTriangle2, pointInAABB, pointInCircle, pointInSegment, pointInPolygon2, pointInRect, pointInTriangle2 } from '@thi.ng/geom-isec/point';
import { sign } from '@thi.ng/math/abs';
import { clipLineSegmentPoly } from '@thi.ng/geom-clip-line/clip-poly';
import { sutherlandHodgeman } from '@thi.ng/geom-clip-poly';
import { closestPoint as closestPoint$1 } from '@thi.ng/geom-arc/closest-point';
import { closestPointAABB, closestPointRect } from '@thi.ng/geom-closest-point/box';
import { closestPointCircle } from '@thi.ng/geom-closest-point/circle';
import { closestPointSegment, closestPointPolyline, closestT } from '@thi.ng/geom-closest-point/line';
import { closestPointArray } from '@thi.ng/geom-closest-point/points';
import { closestPointCubic } from '@thi.ng/geom-splines/cubic-closest-point';
import { closestPointQuadratic } from '@thi.ng/geom-splines/quadratic-closest-point';
import { grahamScan2 } from '@thi.ng/geom-hull/graham-scan';
import { partition } from '@thi.ng/transducers/partition';
import { wrapSides } from '@thi.ng/transducers/wrap-sides';
import { minNonZero2, minNonZero3, clamp01 } from '@thi.ng/math/interval';
import { safeDiv } from '@thi.ng/math/safe-div';
import { concat } from '@thi.ng/matrices/concat';
import { scale23, scale44 } from '@thi.ng/matrices/scale';
import { translation23, translation44 } from '@thi.ng/matrices/translation';
import { neg } from '@thi.ng/vectors/neg';
import { div } from '@thi.ng/vectors/div';
import { madd, madd2 } from '@thi.ng/vectors/madd';
import { mixBilinear } from '@thi.ng/vectors/mix-bilinear';
import { IntersectionType } from '@thi.ng/geom-api/isec';
import { intersectCircleCircle } from '@thi.ng/geom-isec/circle-circle';
import { intersectLineLine } from '@thi.ng/geom-isec/line-line';
import { intersectPlanePlane } from '@thi.ng/geom-isec/plane-plane';
import { intersectRayCircle } from '@thi.ng/geom-isec/ray-circle';
import { intersectRayPlane } from '@thi.ng/geom-isec/ray-plane';
import { intersectRayPolyline } from '@thi.ng/geom-isec/ray-poly';
import { intersectRayAABB, intersectRayRect } from '@thi.ng/geom-isec/ray-rect';
import { testRectCircle } from '@thi.ng/geom-isec/rect-circle';
import { testRectRect } from '@thi.ng/geom-isec/rect-rect';
import { addN2 } from '@thi.ng/vectors/addn';
import { normalCW } from '@thi.ng/vectors/normal';
import { Sampler } from '@thi.ng/geom-resample/sampler';
import { fit01 } from '@thi.ng/math/fit';
import { mixCubic } from '@thi.ng/vectors/mix-cubic';
import { mixQuadratic } from '@thi.ng/vectors/mix-quadratic';
import { pointOnRay2, pointOnRay3 } from '@thi.ng/vectors/point-on-ray';
import { isInArray } from '@thi.ng/vectors/eqdelta';
import { resample as resample$1 } from '@thi.ng/geom-resample/resample';
import { SYSTEM } from '@thi.ng/random/system';
import { randMinMax } from '@thi.ng/vectors/random';
import { simplify as simplify$1 } from '@thi.ng/geom-resample/simplify';
import { cubicSplitAt, splitCubicNearPoint } from '@thi.ng/geom-splines/cubic-split';
import { quadraticSplitAt, quadraticSplitNearPoint } from '@thi.ng/geom-splines/quadratic-split';
import { subdivide } from '@thi.ng/geom-subdiv-curve/subdivide';
import { cubicTangentAt } from '@thi.ng/geom-splines/cubic-tangent';
import { quadraticTangentAt } from '@thi.ng/geom-splines/quadratic-tangent';
import { direction } from '@thi.ng/vectors/direction';
import { tessellate as tessellate$1 } from '@thi.ng/geom-tessellate/tessellate';
import '@thi.ng/checks/is-array';
import '@thi.ng/geom-api/sample';
import '@thi.ng/geom-arc/sample';
import '@thi.ng/geom-splines/cubic-sample';
import '@thi.ng/geom-splines/quadratic-sample';
import '@thi.ng/geom-poly-utils/circumcenter';
import '@thi.ng/checks/is-plain-object';

class AABB {
    constructor(pos = [0, 0, 0], size = 1, attribs) {
        this.pos = pos;
        this.attribs = attribs;
        this.size = isNumber(size) ? [size, size, size] : size;
    }
    get type() {
        return "aabb";
    }
    copy() {
        return new AABB(set([], this.pos), set([], this.size), __copyAttribs(this));
    }
    max() {
        return add3([], this.pos, this.size);
    }
}

class Arc {
    constructor(pos, r, axis, start, end, xl = false, cw = false, attribs) {
        this.pos = pos;
        this.r = r;
        this.axis = axis;
        this.start = start;
        this.end = end;
        this.xl = xl;
        this.cw = cw;
        this.attribs = attribs;
    }
    get type() {
        return "arc";
    }
    copy() {
        return new Arc(set([], this.pos), set([], this.r), this.axis, this.start, this.end, this.xl, this.cw, __copyAttribs(this));
    }
    equiv(o) {
        return (o instanceof Arc &&
            equiv(this.pos, o.pos) &&
            equiv(this.r, o.r) &&
            this.start === o.start &&
            this.end === o.end &&
            this.axis === o.axis &&
            this.xl === o.xl &&
            this.cw &&
            o.cw);
    }
    pointAt(t, out = []) {
        return pointAt$1(this.pos, this.r, this.axis, this.start, this.end, t, out);
    }
    pointAtTheta(theta, out = []) {
        return pointAtTheta(this.pos, this.r, this.axis, theta, out);
    }
    toHiccup() {
        return [
            "path",
            this.attribs,
            [["M", this.pointAt(0)], ...this.toHiccupPathSegments()],
        ];
    }
    toHiccupPathSegments() {
        return [
            [
                "A",
                this.r[0],
                this.r[1],
                this.axis,
                this.xl,
                this.cw,
                this.pointAt(1),
            ],
        ];
    }
}

class Cubic extends APC {
    get type() {
        return "cubic";
    }
    copy() {
        return __copyShape(Cubic, this);
    }
    toHiccup() {
        return [
            "path",
            this.attribs,
            [["M", this.points[0]], ...this.toHiccupPathSegments()],
        ];
    }
    toHiccupPathSegments() {
        const pts = this.points;
        return [["C", pts[1], pts[2], pts[3]]];
    }
}

class Ellipse {
    constructor(pos = [0, 0], r = [1, 1], attribs) {
        this.pos = pos;
        this.attribs = attribs;
        this.r = isNumber(r) ? [r, r] : r;
    }
    get type() {
        return "ellipse";
    }
    copy() {
        return new Ellipse(set([], this.pos), set([], this.r), __copyAttribs(this));
    }
    toHiccup() {
        return ["ellipse", this.attribs, this.pos, this.r];
    }
}

class Group {
    constructor(attribs, children = []) {
        this.attribs = attribs;
        this.children = children;
    }
    get type() {
        return "group";
    }
    *[Symbol.iterator]() {
        yield* this.children;
    }
    copy() {
        return this.copyTransformed((c) => c.copy());
    }
    copyTransformed(fn) {
        return new Group(__copyAttribs(this), this.children.map(fn));
    }
    equiv(o) {
        return o instanceof Group && equiv(this.children, o.children);
    }
    toHiccup() {
        return ["g", this.attribs, ...this.children.map((x) => x.toHiccup())];
    }
}

class Line extends APC {
    get type() {
        return "line";
    }
    copy() {
        return __copyShape(Line, this);
    }
    toHiccup() {
        return ["line", this.attribs, this.points[0], this.points[1]];
    }
    toHiccupPathSegments() {
        const [a, b] = this.points;
        return [
            a[0] === b[0]
                ? ["V", b[1]]
                : a[1] === b[1]
                    ? ["H", b[0]]
                    : ["L", b],
        ];
    }
}

class Path {
    constructor(segments = [], attribs) {
        this.segments = segments;
        this.attribs = attribs;
        this.closed = false;
    }
    get type() {
        return "path";
    }
    *[Symbol.iterator]() {
        yield* this.segments;
    }
    copy() {
        const p = new Path(this.segments.map((s) => {
            const d = { type: s.type };
            s.point && (d.point = copy(s.point));
            s.geo && (d.geo = s.geo.copy());
            return d;
        }), __copyAttribs(this));
        p.closed = this.closed;
        return p;
    }
    equiv(o) {
        return o instanceof Path && equiv(this.segments, o.segments);
    }
    add(s) {
        if (this.closed)
            illegalState("path already closed");
        this.segments.push(s);
    }
    toHiccup() {
        let dest = [];
        const segments = this.segments;
        const n = segments.length;
        if (n > 1) {
            for (let i = 0; i < n; i++) {
                const s = segments[i];
                if (s.geo) {
                    dest = dest.concat(s.geo.toHiccupPathSegments());
                }
                else if (s.point) {
                    dest.push(["M", s.point]);
                }
            }
            if (this.closed) {
                dest.push(["Z"]);
            }
        }
        return ["path", this.attribs || {}, dest];
    }
}

class Plane {
    constructor(normal = [0, 1, 0], w = 0, attribs) {
        this.normal = normal;
        this.w = w;
        this.attribs = attribs;
    }
    get type() {
        return "plane";
    }
    copy() {
        return new Plane(set([], this.normal), this.w, __copyAttribs(this));
    }
    toHiccup() {
        return ["plane", this.attribs, this.normal, this.w];
    }
}

class Points extends APC {
    get type() {
        return "points";
    }
    copy() {
        return __copyShape(Points, this);
    }
    toHiccup() {
        return ["points", this.attribs, this.points];
    }
}
class Points3 extends APC {
    get type() {
        return "points3";
    }
    copy() {
        return __copyShape(Points3, this);
    }
    toHiccup() {
        return ["points3", this.attribs, this.points];
    }
}

class Polyline extends APC {
    get type() {
        return "polyline";
    }
    copy() {
        return __copyShape(Polyline, this);
    }
    toHiccup() {
        return ["polyline", { ...this.attribs, fill: "none" }, this.points];
    }
    toHiccupPathSegments() {
        const res = [];
        for (let pts = this.points, n = pts.length, i = 1; i < n; i++) {
            res.push(["L", pts[i]]);
        }
        return res;
    }
}

class Quad extends APC {
    get type() {
        return "quad";
    }
    copy() {
        return __copyShape(Quad, this);
    }
    toHiccup() {
        return ["polygon", this.attribs, this.points];
    }
}

class Quad3 extends APC {
    get type() {
        return "quad3";
    }
    copy() {
        return __copyShape(Quad3, this);
    }
    toHiccup() {
        return ["polygon", this.attribs, this.points];
    }
}

class Quadratic extends APC {
    get type() {
        return "quadratic";
    }
    copy() {
        return __copyShape(Quadratic, this);
    }
    toHiccup() {
        return [
            "path",
            this.attribs,
            [["M", this.points[0]], ...this.toHiccupPathSegments()],
        ];
    }
    toHiccupPathSegments() {
        const pts = this.points;
        return [["Q", pts[1], pts[2]]];
    }
}

class Ray {
    constructor(pos, dir, attribs) {
        this.pos = pos;
        this.dir = dir;
        this.attribs = attribs;
    }
    get type() {
        return "ray";
    }
    copy() {
        return new Ray(set([], this.pos), set([], this.dir), __copyAttribs(this));
    }
    toHiccup() {
        return [
            "line",
            this.attribs,
            this.pos,
            maddN2([], this.dir, 1e6, this.pos),
        ];
    }
}

class Rect {
    constructor(pos = [0, 0], size = 1, attribs) {
        this.pos = pos;
        this.attribs = attribs;
        this.size = isNumber(size) ? [size, size] : size;
    }
    get type() {
        return "rect";
    }
    copy() {
        return new Rect(set2([], this.pos), set2([], this.size), __copyAttribs(this));
    }
    max() {
        return add2([], this.pos, this.size);
    }
    toHiccup() {
        return ["rect", this.attribs, this.pos, this.size[0], this.size[1]];
    }
}

class Sphere {
    constructor(pos = [0, 0, 0], r = 1, attribs) {
        this.pos = pos;
        this.r = r;
        this.attribs = attribs;
    }
    get type() {
        return "sphere";
    }
    copy() {
        return new Sphere(set3([], this.pos), this.r, __copyAttribs(this));
    }
    toHiccup() {
        return ["sphere", this.attribs, this.pos, this.r];
    }
}

/**
 * Basic stub for text elements. Currently, only a minimal set of geometry
 * operations are implemented for this type, however this type implements
 * {@link @this.ng/api#IToHiccup} and so is useful as wrapper for inclusion of
 * text elements in {@link Group}s with other shape types.
 */
class Text {
    constructor(pos, body, attribs) {
        this.pos = pos;
        this.body = body;
        this.attribs = attribs;
    }
    get type() {
        return "text";
    }
    copy() {
        return new Text(set([], this.pos), this.body, __copyAttribs(this));
    }
    toHiccup() {
        return ["text", this.attribs, this.pos, this.body];
    }
}

class Triangle extends APC {
    get type() {
        return "tri";
    }
    copy() {
        return __copyShape(Triangle, this);
    }
    toHiccup() {
        return ["polygon", this.attribs, this.points];
    }
}

function aabb(...args) {
    return new AABB(...__argsVV(args));
}
const aabbFromMinMax = (min, max, attribs) => new AABB(min, sub3([], max, min), attribs);
/**
 * Returns the intersection AABB of given inputs or `undefined` if they
 * are non-overlapping.
 *
 * @param a
 * @param b
 */
const intersectionAABB = (a, b) => {
    const p = max3([], a.pos, b.pos);
    const q = min3(null, add3([], a.pos, a.size), add3([], b.pos, b.size));
    const size = max3(null, sub3(null, q, p), ZERO3);
    return size[0] > 0 && size[1] > 0 && size[2] > 0
        ? new AABB(p, size)
        : undefined;
};
function inscribedAABB(...args) {
    let pos, r;
    if (args.length === 1) {
        const c = args[0];
        pos = c.pos;
        r = c.r;
    }
    else {
        [pos, r] = args;
    }
    r *= SQRT2_2;
    return aabb(subN3([], pos, r), r * 2);
}

const arc = (pos, r, axis, start, end, xl = false, clockwise = false) => new Arc(pos, isNumber(r) ? [r, r] : r, axis, start, end, xl, clockwise);
const arcFrom2Points = (a, b, radii, axis = 0, xl = false, cw = false, attribs) => {
    const res = fromEndPoints(a, b, radii, axis, xl, cw);
    return res
        ? new Arc(res.center, res.r, res.axis, res.start, res.end, res.xl, res.cw, attribs)
        : undefined;
};

const __pclike = (ctor, args) => {
    const attr = __argAttribs(args);
    return new ctor(args.length === 1 ? args[0] : args, attr);
};

function cubic(...args) {
    return __pclike(Cubic, args);
}
const cubicFromArc = (arc) => cubicFromArc$1(arc.pos, arc.r, arc.axis, arc.start, arc.end).map((c) => new Cubic(c, __copyAttribs(arc)));
const cubicFromLine = (a, b, attribs) => new Cubic(cubicFromLine$1(a, b), attribs);
const cubicFromQuadratic = (a, b, c, attribs) => new Cubic(cubicFromQuadratic$1(a, b, c), attribs);

function ellipse(...args) {
    return new Ellipse(...__argsVV(args));
}

const group = (attribs = {}, children) => new Group(attribs, children);

function line(...args) {
    return __pclike(Line, args);
}
const clippedLine = (l, bounds) => {
    const res = bounds instanceof Rect
        ? liangBarsky2(l.points[0], l.points[1], bounds.pos, bounds.max())
        : liangBarsky2(l.points[0], l.points[1], bounds[0], bounds[1]);
    if (res) {
        return new Line([res[0], res[1]], { ...l.attribs });
    }
};

const asCubic = defmulti(__dispatch, {
    ellipse: "circle",
    quad: "poly",
    tri: "poly",
}, {
    arc: cubicFromArc,
    circle: ($) => asCubic(arc($.pos, $.r, 0, 0, TAU, true, true)),
    cubic: ($) => [$],
    group: ($) => [...mapcat(asCubic, $.children)],
    line: ({ attribs, points }) => [
        cubicFromLine(points[0], points[1], { ...attribs }),
    ],
    path: ($) => [
        ...mapcat((s) => (s.geo ? asCubic(s.geo) : null), $.segments),
    ],
    poly: ($, opts = {}) => polyCubic($, opts, closedCubicFromBreakPoints, closedCubicFromControlPoints),
    polyline: ($, opts = {}) => polyCubic($, opts, openCubicFromBreakPoints, openCubicFromControlPoints),
    quadratic: ({ attribs, points }) => [
        cubicFromQuadratic(points[0], points[1], points[2], { ...attribs }),
    ],
    rect: ($, opts) => asCubic(asPolygon($), opts),
});
// prettier-ignore
const polyCubic = ($, opts, breakPoints, controlPoints) => {
    opts = { breakPoints: false, scale: 1 / 3, uniform: false, ...opts };
    return (opts.breakPoints
        ? breakPoints($.points, opts.scale, opts.uniform)
        : controlPoints($.points, opts.scale, opts.uniform)).map((pts) => new Cubic(pts, __copyAttribs($)));
};

class PathBuilder {
    constructor(attribs, opts = {}) {
        this.attribs = attribs;
        this.opts = opts;
        this.paths = [];
        this.attribs = attribs;
        this.newPath();
    }
    *[Symbol.iterator]() {
        yield* this.paths;
    }
    current() {
        return this.curr;
    }
    newPath() {
        this.curr = new Path([], this.attribs);
        this.paths.push(this.curr);
        this.currP = zeroes(2);
        this.bezierP = zeroes(2);
        this.startP = zeroes(2);
    }
    moveTo(p, relative = false) {
        if (this.opts.autoSplit !== false && this.curr.segments.length > 0) {
            this.curr = new Path([], this.attribs);
            this.paths.push(this.curr);
        }
        p = this.updateCurrent(p, relative);
        set2(this.startP, p);
        set2(this.bezierP, p);
        this.curr.add({
            point: p,
            type: "m",
        });
        return this;
    }
    lineTo(p, relative = false) {
        this.curr.add({
            geo: new Line([copy(this.currP), this.updateCurrent(p, relative)]),
            type: "l",
        });
        set2(this.bezierP, this.currP);
        return this;
    }
    hlineTo(x, relative = false) {
        this.addHVLine(x, 0, relative);
        return this;
    }
    vlineTo(y, relative = false) {
        this.addHVLine(y, 1, relative);
        return this;
    }
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Cubic_B%C3%A9zier_Curve
    cubicTo(cp1, cp2, p, relative = false) {
        this.addCubic(this.absPoint(cp1, relative), cp2, p, relative);
        return this;
    }
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Quadratic_B%C3%A9zier_Curve
    quadraticTo(cp, p, relative = false) {
        this.addQuadratic(this.absPoint(cp, relative), p, relative);
        return this;
    }
    cubicChainTo(cp2, p, relative = false) {
        const prevMode = peek(this.curr.segments).type;
        const c1 = copy(this.currP);
        prevMode === "c" && add2(null, sub2([], c1, this.bezierP), c1);
        this.addCubic(c1, cp2, p, relative);
        return this;
    }
    quadraticChainTo(p, relative = false) {
        const prevMode = peek(this.curr.segments).type;
        const c1 = copy(this.currP);
        prevMode === "q" && sub2(null, mulN2(null, c1, 2), this.bezierP);
        this.addQuadratic(c1, p, relative);
        return this;
    }
    arcTo(p, r, xaxis, xl, clockwise, relative = false) {
        if (eqDelta(r[0], 0) || eqDelta(r[1], 0)) {
            return this.lineTo(p, relative);
        }
        const prev = copy(this.currP);
        this.curr.add({
            geo: arcFrom2Points(prev, this.updateCurrent(p, relative), r, xaxis, xl, clockwise),
            type: "a",
        });
        set2(this.bezierP, this.currP);
        return this;
    }
    closePath() {
        this.curr.add({
            geo: new Line([copy(this.currP), copy(this.startP)]),
            type: "l",
        });
        this.curr.closed = true;
        return this;
    }
    updateCurrent(p, relative) {
        p = copy(relative ? add2(null, this.currP, p) : set2(this.currP, p));
        return p;
    }
    absPoint(p, relative) {
        return relative ? add2(null, p, this.currP) : p;
    }
    addHVLine(p, i, relative) {
        const prev = copy(this.currP);
        this.currP[i] = relative ? this.currP[i] + p : p;
        set2(this.bezierP, this.currP);
        this.curr.add({
            geo: new Line([prev, copy(this.currP)]),
            type: "l",
        });
    }
    addCubic(cp1, cp2, p, relative) {
        cp2 = this.absPoint(cp2, relative);
        set2(this.bezierP, cp2);
        this.curr.add({
            geo: new Cubic([
                copy(this.currP),
                cp1,
                cp2,
                this.updateCurrent(p, relative),
            ]),
            type: "c",
        });
    }
    addQuadratic(cp, p, relative) {
        set2(this.bezierP, cp);
        this.curr.add({
            geo: new Quadratic([
                copy(this.currP),
                cp,
                this.updateCurrent(p, relative),
            ]),
            type: "q",
        });
    }
}
const pathBuilder = (attribs, opts) => new PathBuilder(attribs, opts);

const path = (segments, attribs) => new Path(segments, attribs);
const pathFromCubics = (cubics, attribs) => {
    const path = new Path([], attribs || cubics[0].attribs);
    path.segments.push({ type: "m", point: cubics[0].points[0] });
    for (let c of cubics) {
        path.segments.push({ type: "c", geo: c });
    }
    return path;
};
const normalizedPath = (path) => new Path([
    ...mapcat((s) => s.geo
        ? map((c) => ({ type: "c", geo: c }), asCubic(s.geo))
        : [{ ...s }], path.segments),
], path.attribs);
const roundedRect = (pos, size, r, attribs) => {
    r = isNumber(r) ? [r, r] : r;
    const [w, h] = maddN2([], r, -2, size);
    return new PathBuilder(attribs)
        .moveTo([pos[0] + r[0], pos[1]])
        .hlineTo(w, true)
        .arcTo(r, r, 0, false, true, true)
        .vlineTo(h, true)
        .arcTo([-r[0], r[1]], r, 0, false, true, true)
        .hlineTo(-w, true)
        .arcTo([-r[0], -r[1]], r, 0, false, true, true)
        .vlineTo(-h, true)
        .arcTo([r[0], -r[1]], r, 0, false, true, true)
        .current();
};

const CMD_RE = /[achlmqstvz]/i;
const WSC = { ...WS, ",": true };
const pathFromSvg = (svg) => {
    const b = new PathBuilder();
    try {
        let cmd = "";
        for (let n = svg.length, i = 0; i < n;) {
            i = skipWS(svg, i);
            const c = svg.charAt(i);
            if (CMD_RE.test(c)) {
                cmd = c;
                i++;
            }
            let p, pa, pb, t1, t2, t3;
            switch (cmd.toLowerCase()) {
                case "m":
                    [p, i] = readPoint(svg, i);
                    b.moveTo(p, cmd === "m");
                    break;
                case "l":
                    [p, i] = readPoint(svg, i);
                    b.lineTo(p, cmd === "l");
                    break;
                case "h":
                    [p, i] = readFloat(svg, i);
                    b.hlineTo(p, cmd === "h");
                    break;
                case "v":
                    [p, i] = readFloat(svg, i);
                    b.vlineTo(p, cmd === "v");
                    break;
                case "q":
                    [pa, i] = readPoint(svg, i);
                    [p, i] = readPoint(svg, i);
                    b.quadraticTo(pa, p, cmd === "q");
                    break;
                case "c":
                    [pa, i] = readPoint(svg, i);
                    [pb, i] = readPoint(svg, i);
                    [p, i] = readPoint(svg, i);
                    b.cubicTo(pa, pb, p, cmd === "c");
                    break;
                case "s":
                    [pa, i] = readPoint(svg, i);
                    [p, i] = readPoint(svg, i);
                    b.cubicChainTo(pa, p, cmd === "s");
                    break;
                case "t":
                    [p, i] = readPoint(svg, i);
                    b.quadraticChainTo(p, cmd === "t");
                    break;
                case "a": {
                    [pa, i] = readPoint(svg, i);
                    [t1, i] = readFloat(svg, i);
                    [t2, i] = readFlag(svg, i);
                    [t3, i] = readFlag(svg, i);
                    [pb, i] = readPoint(svg, i);
                    b.arcTo(pb, pa, rad(t1), t2, t3, cmd === "a");
                    break;
                }
                case "z":
                    b.closePath();
                    break;
                default:
                    throw new Error(`unsupported segment type: ${c} @ pos ${i}`);
            }
        }
        return b.paths;
    }
    catch (e) {
        throw e instanceof Error
            ? e
            : new Error(`illegal char '${svg.charAt(e)}' @ ${e}`);
    }
};
const skipWS = (src, i) => {
    const n = src.length;
    while (i < n && WSC[src.charAt(i)])
        i++;
    return i;
};
const readPoint = (src, index) => {
    let x, y;
    [x, index] = readFloat(src, index);
    index = skipWS(src, index);
    [y, index] = readFloat(src, index);
    return [[x, y], index];
};
const readFlag = (src, i) => {
    i = skipWS(src, i);
    const c = src.charAt(i);
    return [
        c === "0"
            ? false
            : c === "1"
                ? true
                : illegalState(`expected '0' or '1' @ pos: ${i}`),
        i + 1,
    ];
};
const readFloat = (src, index) => {
    index = skipWS(src, index);
    let signOk = true;
    let dotOk = true;
    let expOk = false;
    let commaOk = false;
    let i = index;
    for (let n = src.length; i < n; i++) {
        const c = src.charAt(i);
        if ("0" <= c && c <= "9") {
            expOk = true;
            commaOk = true;
            signOk = false;
            continue;
        }
        if (c === "-" || c === "+") {
            if (!signOk)
                break;
            signOk = false;
            continue;
        }
        if (c === ".") {
            if (!dotOk)
                break;
            dotOk = false;
            continue;
        }
        if (c === "e") {
            if (!expOk)
                throw i;
            expOk = false;
            dotOk = false;
            signOk = true;
            continue;
        }
        if (c === ",") {
            if (!commaOk)
                throw i;
            i++;
        }
        break;
    }
    if (i === index) {
        illegalState(`expected coordinate @ pos: ${i}`);
    }
    return [parseFloat(src.substring(index, i)), i];
};

const plane = (normal, w, attribs) => new Plane(normalize(null, normal), w, attribs);
const planeWithPoint = (normal, p, attribs) => {
    normal = normalize(null, normal);
    return new Plane(normal, dot3(normal, p), attribs);
};
const planeFrom3Points = (a, b, c, attribs) => planeWithPoint(orthoNormal3([], a, b, c), a, attribs);

const points = (pts, attribs) => new Points(pts, attribs);
const points3 = (pts, attribs) => new Points3(pts, attribs);

const polygon = (pts, attribs) => new Polygon(pts, attribs);
const star = (r, n, profile, attribs) => new Polygon(transduce(map(([i, p]) => cartesian2(null, [r * p, i * TAU])), push(), zip(normRange(n * profile.length, false), cycle(profile))), attribs);

const polyline = (pts, attribs) => new Polyline(pts, attribs);

function quad(...args) {
    return __pclike(Quad, args);
}
function quad3(...args) {
    const attr = __argAttribs(args);
    return new Quad3(args.length === 1 ? args[0] : args, attr);
}
const quadOnPlane = (plane, pos, size, attribs) => {
    pos = closestPointPlane(pos, plane.normal, plane.w);
    const [w, h] = isNumber(size) ? [size, size] : size;
    const q = alignmentQuat(Z3, plane.normal);
    return new Quad3([
        [-w, -h, 0],
        [w, -h, 0],
        [w, h, 0],
        [-w, h, 0],
    ].map((p) => add3(null, mulVQ(null, q, p), pos)), attribs);
};

function quadratic(...args) {
    return __pclike(Quadratic, args);
}
const quadraticFromLine = (a, b, attribs) => new Quadratic(quadraticFromLine$1(a, b), attribs);

const ray = (pos, dir, attribs, normalize$1 = true) => new Ray(pos, normalize$1 ? normalize(null, dir) : dir, attribs);

function rect(...args) {
    return new Rect(...__argsVV(args));
}
const rectFromMinMax = (min, max, attribs) => new Rect(min, sub2([], max, min), attribs);
const rectFromCentroid = (centroid, size, attribs) => new Rect(maddN2([], size, -0.5, centroid), size, attribs);
/**
 * Returns the intersection rect of given inputs or `undefined` if they
 * are non-overlapping.
 *
 * @param a
 * @param b
 */
const intersectionRect = (a, b) => {
    const p = max2([], a.pos, b.pos);
    const q = min2(null, add2([], a.pos, a.size), add2([], b.pos, b.size));
    const size = max2(null, sub2(null, q, p), ZERO2);
    return size[0] > 0 && size[1] > 0 ? new Rect(p, size) : undefined;
};
function inscribedSquare(...args) {
    let pos, r;
    if (args.length === 1) {
        const c = args[0];
        pos = c.pos;
        r = c.r;
    }
    else {
        [pos, r] = args;
    }
    r *= SQRT2_2;
    return rect(subN2([], pos, r), r * 2);
}
function inscribedSquareHex(...args) {
    let pos, l;
    if (args.length === 1) {
        const pts = args[0].points;
        pos = centroid$1(pts);
        l = dist(pts[0], pts[1]);
    }
    else {
        [pos, l] = args;
    }
    l *= 3 - SQRT3;
    return rect(subN2([], pos, l / 2), l);
}

const text = (pos, body, attribs) => new Text(pos, body, attribs);

function triangle(...args) {
    return __pclike(Triangle, args);
}
const equilateralTriangle = (a, b, attribs) => new Triangle(equilateralTriangle2(a, b), attribs);

/**
 * Returns the arc length / perimeter / circumference of the given
 * shape. For groups calls {@link arcLength} for each child and returns the
 * sum of results.
 *
 * Implemented for:
 *
 * - Circle
 * - Ellipse
 * - Group
 * - Line
 * - Polygon
 * - Polyline
 * - Quad
 * - Rect
 * - Triangle
 *
 */
const arcLength = defmulti(__dispatch, {
    quad: "poly",
    tri: "poly",
}, {
    circle: ($) => TAU * $.r,
    ellipse: ({ r: [a, b] }) => 
    // Ramanujan approximation
    // https://www.mathsisfun.com/geometry/ellipse-perimeter.html
    PI * (3 * (a + b) - Math.sqrt((3 * a + b) * (3 * b + a))),
    group: ({ children }) => children.reduce((sum, $) => sum + arcLength($), 0),
    line: ({ points }) => dist(points[0], points[1]),
    poly: ({ points }) => perimeter(points, points.length, true),
    polyline: ({ points }) => perimeter(points, points.length),
    rect: ({ size }) => 2 * (size[0] + size[1]),
    tri: ({ points }) => dist(points[0], points[1]) +
        dist(points[1], points[2]) +
        dist(points[2], points[0]),
});

/**
 * Returns the possibly signed (unsigned by default) surface area of given
 * `shape`. For groups calls {@link area} for each child and returns sum of
 * unsigned areas.
 *
 * In general, for polygons and triangles, the sign of the result can be
 * used as indication of the shapes orientation (clockwise /
 * counterclockwise).
 *
 * For curves, lines, point clouds and rays the function returns 0.
 *
 * Implemented for:
 *
 * - AABB
 * - Circle
 * - Cubic
 * - Ellipse
 * - Group
 * - Line
 * - Plane
 * - Points
 * - Polygon
 * - Polyline
 * - Quad
 * - Quadratic
 * - Ray
 * - Rect
 * - Sphere
 * - Triangle
 *
 * @param shape - shape to operate on
 * @param signed - true, if signed area
 */
const area = defmulti(__dispatch, { quad: "poly" }, {
    aabb: ({ size: [w, h, d] }) => 2 * (w * h + w * d + h * d),
    arc: 
    // http://cut-the-knot.org/Generalization/Cavalieri2.shtml
    ($) => 0.5 * Math.abs($.start - $.end) * $.r[0] * $.r[1],
    circle: ($) => PI * $.r ** 2,
    ellipse: ($) => PI * $.r[0] * $.r[1],
    group: ({ children }) => children.reduce((sum, $) => sum + area($, false), 0),
    plane: () => Infinity,
    poly: ($, signed) => {
        const area = polyArea2($.points);
        return signed ? area : Math.abs(area);
    },
    rect: ($) => $.size[0] * $.size[1],
    sphere: ($) => 4 * PI * $.r ** 2,
    tri: ($, signed) => {
        const area = 0.5 * signedArea2(...$.points);
        return signed ? area : Math.abs(area);
    },
    [DEFAULT]: () => 0,
});

const asPath = (src, attribs) => pathFromCubics(asCubic(src), attribs || __copyAttribs(src));

const asPolyline = defmulti(__dispatch, {
    arc: "points",
    circle: "poly",
    cubic: "points",
    ellipse: "poly",
    line: "points",
    polyline: "points",
    quad: "poly",
    quadratic: "points",
    rect: "poly",
    tri: "poly",
}, {
    points: ($, opts) => new Polyline(vertices($, opts), __copyAttribs($)),
    path: ($, opts) => {
        const pts = vertices($, opts);
        $.closed && pts.push(set([], pts[0]));
        return new Polyline(pts, __copyAttribs($));
    },
    poly: ($, opts) => {
        const pts = vertices($, opts);
        pts.push(set([], pts[0]));
        return new Polyline(pts, __copyAttribs($));
    },
});

/**
 * Computes the total bounds for the given shape collection, which
 * should either contain only 2D or 3D types. No mixed dimensions are
 * allowed! Currently the {@link bounds} function MUST be passed in as
 * arg to avoid circular module dependencies.
 *
 * @param shapes - input shapes
 * @param bounds - bbox function
 */
const __collBounds = (shapes, bounds) => {
    let n = shapes.length - 1;
    if (n < 0)
        return;
    let b = bounds(shapes[n]);
    if (!b)
        return;
    let { pos, size } = b;
    for (; --n >= 0;) {
        b = bounds(shapes[n]);
        if (!b)
            continue;
        [pos, size] = __unionBounds(pos, size, b.pos, b.size);
    }
    return [pos, size];
};
/**
 * Takes the position and size vectors of 2
 * {@link @thi.ng/geom-api#AABBLike}s and returns 2-tuple of
 * `[pos,size]` of their union bounds.
 *
 * @param apos - bbox 1 min pos
 * @param asize - bbox1 size
 * @param bpos - bbox 2 min pos
 * @param bsize - bbox 2 size
 */
const __unionBounds = (apos, asize, bpos, bsize) => {
    const p = add([], apos, asize);
    const q = add([], bpos, bsize);
    const pos = min([], apos, bpos);
    return [pos, sub(null, max(null, p, q), pos)];
};

const bounds = defmulti(__dispatch, {
    aabb: "rect",
    poly: "points",
    polyline: "points",
    quad: "points",
    tri: "points",
}, {
    arc: ($) => rectFromMinMax(...bounds$1($.pos, $.r, $.axis, $.start, $.end)),
    circle: ($) => new Rect(subN2([], $.pos, $.r), mulN2(null, [2, 2], $.r)),
    cubic: ({ points }) => rectFromMinMax(...cubicBounds(points[0], points[1], points[2], points[3])),
    ellipse: ($) => new Rect(sub2([], $.pos, $.r), mul2(null, [2, 2], $.r)),
    group: ($) => {
        const res = __collBounds($.children, bounds);
        return res ? new Rect(...res) : undefined;
    },
    line: ({ points: [a, b] }) => rectFromMinMax(min([], a, b), max([], a, b)),
    path: (path) => {
        const b = __collBounds([
            ...iterator1(comp(map((s) => s.geo), filter((s) => !!s)), path.segments),
        ], bounds);
        return b ? new Rect(...b) : undefined;
    },
    points: ($) => rectFromMinMax(...bounds$2($.points, set2([], MAX2), set2([], MIN2))),
    points3: ($) => aabbFromMinMax(...bounds$2($.points, set3([], MAX3), set3([], MIN3))),
    quadratic: ({ points }) => rectFromMinMax(...quadraticBounds(points[0], points[1], points[2])),
    rect: ($) => $.copy(),
    text: ($) => new Rect(set2([], $.pos), [0, 0]),
});

const asSvg = (...args) => args.map((x) => serialize(convertTree(x))).join("");
const svgDoc = (attribs, ...xs) => {
    if (xs.length > 0) {
        if (!attribs || !attribs.viewBox) {
            const cbounds = __collBounds(xs, bounds);
            if (cbounds) {
                const [[x, y], [w, h]] = cbounds;
                attribs = {
                    width: ff(w),
                    height: ff(h),
                    viewBox: `${ff(x)} ${ff(y)} ${ff(w)} ${ff(h)}`,
                    ...attribs,
                };
            }
        }
    }
    return svg(attribs, ...xs);
};

const centroid = defmulti(__dispatch, {
    arc: "circle",
    aabb: "rect",
    ellipse: "circle",
    line3: "line",
    points3: "points",
    polyline: "points",
    quad: "poly",
    sphere: "circle",
    text: "circle",
    tri3: "tri",
}, {
    circle: ($, out) => set(out || [], $.pos),
    group: ($) => {
        const b = bounds($);
        return b ? centroid(b) : undefined;
    },
    line: ({ points }, out) => mixN(out || [], points[0], points[1], 0.5),
    points: ($, out) => centroid$1($.points, out),
    plane: ($, out) => mulN(out || [], $.normal, $.w),
    poly: ($, out) => centerOfWeight2($.points, out),
    rect: ($, out) => maddN(out || [], $.size, 0.5, $.pos),
    tri: ({ points }, out) => divN(null, add(null, add(out || [], points[0], points[1]), points[2]), 3),
});

const __translatedPoints = (pts, delta) => pts.map((x) => add([], x, delta));
const __translatedShape = (ctor) => ($, delta) => new ctor(__translatedPoints($.points, delta), __copyAttribs($));

const translate = defmulti(__dispatch, {}, {
    aabb: ($, delta) => new AABB(add3([], $.pos, delta), set3([], $.size), __copyAttribs($)),
    arc: ($, delta) => {
        const a = $.copy();
        add2(null, a.pos, delta);
        return a;
    },
    circle: ($, delta) => new Circle(add2([], $.pos, delta), $.r, __copyAttribs($)),
    cubic: __translatedShape(Cubic),
    ellipse: ($, delta) => new Ellipse(add2([], $.pos, delta), set2([], $.r), __copyAttribs($)),
    group: ($, delta) => $.copyTransformed((x) => translate(x, delta)),
    line: __translatedShape(Line),
    path: ($, delta) => new Path($.segments.map((s) => s.geo
        ? {
            type: s.type,
            geo: translate(s.geo, delta),
        }
        : {
            type: s.type,
            point: add2([], s.point, delta),
        }), __copyAttribs($)),
    points: __translatedShape(Points),
    points3: __translatedShape(Points3),
    poly: __translatedShape(Polygon),
    polyline: __translatedShape(Polyline),
    quad: __translatedShape(Quad),
    quadratic: __translatedShape(Quadratic),
    ray: ($, delta) => new Ray(add2([], $.pos, delta), $.dir, __copyAttribs($)),
    rect: ($, delta) => new Rect(add2([], $.pos, delta), set2([], $.size), __copyAttribs($)),
    sphere: ($, delta) => new Sphere(add3([], $.pos, delta), $.r, __copyAttribs($)),
    text: ($, delta) => new Text(add2([], $.pos, delta), $.body, __copyAttribs($)),
    tri: __translatedShape(Triangle),
});

const center = defmulti(__dispatch, {}, {
    [DEFAULT]: ($, origin = ZERO3) => {
        const c = centroid($);
        return c ? translate($, submN(null, c, origin, -1)) : undefined;
    },
    arc: ($, origin = ZERO2) => new Arc(set2([], origin), set2([], $.r), $.axis, $.start, $.end, $.xl, $.cw, __copyAttribs($)),
    circle: ($, origin = ZERO2) => new Circle(set2([], origin), $.r, __copyAttribs($)),
    ellipse: ($, origin = ZERO2) => new Ellipse(set2([], origin), set2([], $.r), __copyAttribs($)),
    sphere: ($, origin = ZERO3) => new Sphere(set3([], origin), $.r, __copyAttribs($)),
});

const classifyPoint = defmulti(__dispatch, { sphere: "circle" }, {
    circle: ($, p, eps = EPS) => classifyPointInCircle(p, $.pos, $.r, eps),
    plane: ($, p, eps) => sign(dot($.normal, p) - $.w, eps),
    tri: ({ points }, p, eps = EPS) => classifyPointInTriangle2(p, points[0], points[1], points[2], eps),
});

const clipConvex = defmulti(__dispatch, {
    circle: "rect",
    ellipse: "rect",
    path: "rect",
    quad: "poly",
    tri: "poly",
}, {
    group: ({ children, attribs }, boundary) => {
        boundary = ensureVertices(boundary);
        const clipped = [];
        for (let c of children) {
            const res = clipConvex(c, boundary);
            if (res)
                clipped.push(res);
        }
        return new Group({ ...attribs }, clipped);
    },
    line: ($, boundary) => {
        const segments = clipLineSegmentPoly($.points[0], $.points[1], ensureVertices(boundary));
        return segments && segments.length
            ? new Line(segments[0], __copyAttribs($))
            : undefined;
    },
    poly: ($, boundary) => {
        boundary = ensureVertices(boundary);
        const pts = sutherlandHodgeman($.points, boundary, centroid$1(boundary));
        return pts.length ? new Polygon(pts, __copyAttribs($)) : undefined;
    },
    rect: ($, boundary) => {
        boundary = ensureVertices(boundary);
        const pts = sutherlandHodgeman(vertices($), boundary, centroid$1(boundary));
        return pts.length ? new Polygon(pts, __copyAttribs($)) : undefined;
    },
});

const closestPoint = defmulti(__dispatch, {
    quad: "poly",
    sphere: "circle",
    tri: "poly",
}, {
    aabb: ($, p, out) => closestPointAABB(p, $.pos, add3([], $.pos, $.size), out),
    arc: ($, p, out) => closestPoint$1(p, $.pos, $.r, $.axis, $.start, $.end, out),
    circle: ($, p, out) => closestPointCircle(p, $.pos, $.r, out),
    cubic: ({ points }, p, out) => closestPointCubic(p, points[0], points[1], points[2], points[3], out),
    line: ({ points }, p, out) => closestPointSegment(p, points[0], points[1], out),
    plane: ($, p, out) => closestPointPlane(p, $.normal, $.w, out),
    points: ($, p, out) => closestPointArray(p, $.points, out),
    poly: ($, p, out) => closestPointPolyline(p, $.points, true, out),
    polyline: ($, p, out) => closestPointPolyline(p, $.points, false, out),
    quadratic: ({ points }, p, out) => closestPointQuadratic(p, points[0], points[1], points[2], out),
    rect: ($, p, out) => closestPointRect(p, $.pos, add2([], $.pos, $.size), out),
});

const convexHull = defmulti(__dispatch, {
    circle: "tri",
    ellipse: "tri",
    poly: "points",
    polyline: "points",
    quad: "points",
    rect: "tri",
}, {
    group: ($) => new Polygon(vertices($), __copyAttribs($)),
    points: ($) => new Polygon(grahamScan2($.points), __copyAttribs($)),
    tri: ($) => $.copy(),
});

const __edges = (vertices, closed = false) => (partition(2, 1, closed ? wrapSides(vertices, 0, 1) : vertices));

const edges = defmulti(__dispatch, {
    line: "polyline",
    quad: "poly",
    tri: "poly",
}, {
    aabb: ($) => {
        const [a, b, c, d, e, f, g, h] = vertices($);
        return [
            [a, b],
            [b, c],
            [c, d],
            [d, a],
            [e, f],
            [f, g],
            [g, h],
            [h, e],
            [a, e],
            [b, f],
            [c, g],
            [d, h], // right
        ];
    },
    poly: ($) => __edges($.points, true),
    polyline: ($) => __edges($.points),
    rect: ($) => __edges(vertices($), true),
});

const mapPoint = defmulti(__dispatch, { aabb: "rect" }, {
    rect: ($, p, out = []) => div(null, sub(out, p, $.pos), $.size),
});

const __transformedPoints = (pts, mat, op = mulV) => pts.map((p) => op([], mat, p));
const __transformedPointsWith = (pts, fn, op = mulV) => pts.map((p) => op([], fn(p), p));
const __transformedShape = (ctor) => ($, mat) => new ctor(__transformedPoints($.points, mat), __copyAttribs($));
const __transformedShapePoints = (ctor) => ($, fn) => new ctor(__transformedPointsWith($.points, fn), __copyAttribs($));
const __transformedPoints3 = (pts, mat) => __transformedPoints(pts, mat, mulV344);
const __transformedPointsWith3 = (pts, fn) => __transformedPointsWith(pts, fn, mulV344);
const __transformedShape3 = (ctor) => ($, mat) => new ctor(__transformedPoints3($.points, mat), __copyAttribs($));
const __transformedShapePoints3 = (ctor) => ($, fn) => new ctor(__transformedPointsWith3($.points, fn), __copyAttribs($));

/**
 * Transforms given shape with provided matrix. Some shape types will be
 * automatically converted to other types prior to transformation because they
 * cannot be reliably represented in their original type anymore, this
 * includes:
 *
 * - Arc => Path (cubics)
 * - Circle => Path (cubics)
 * - Ellipse => Path (cubics)
 * - Rect => Polygon
 */
const transform = defmulti(__dispatch, {
    circle: "arc",
    ellipse: "circle",
}, {
    arc: ($, mat) => transform(asPath($), mat),
    cubic: __transformedShape(Cubic),
    group: ($, mat) => $.copyTransformed((x) => transform(x, mat)),
    line: __transformedShape(Line),
    path: ($, mat) => new Path([
        ...map((s) => s.type === "m"
            ? {
                type: s.type,
                point: mulV([], mat, s.point),
            }
            : {
                type: s.type,
                geo: transform(s.geo, mat),
            }, $.segments),
    ], __copyAttribs($)),
    points: __transformedShape(Points),
    points3: __transformedShape3(Points3),
    poly: __transformedShape(Polygon),
    polyline: __transformedShape(Polyline),
    quad: __transformedShape(Quad),
    quadratic: __transformedShape(Quadratic),
    rect: ($, mat) => transform(asPolygon($), mat),
    text: ($, mat) => new Text(mulV([], mat, $.pos), $.body, __copyAttribs($)),
    tri: __transformedShape(Triangle),
});

/**
 * Projects given point `uv` (normalized coords) into the target space
 * defined by `shape` and writes result to `out` (or returns new
 * vector). See {@link mapPoint} for reverse operation. Both functions
 * together can be used to warp points from one shape into another.
 *
 * Currently only implemented for these shape types:
 *
 * - AABB
 * - Quad
 * - Rect
 *
 * @param shape - shape to operate on
 * @param uv - point to map in UV space
 * @param out - result
 */
const unmapPoint = defmulti(__dispatch, {
    aabb: "rect",
    quad3: "quad",
}, {
    quad: ({ points }, uv, out = []) => mixBilinear(out, points[0], points[1], points[3], points[2], uv[0], uv[1]),
    rect: ($, uvw, out = []) => madd(out, $.size, uvw, $.pos),
});

const translateScale = (tmat, smat, shape, preTrans, postTrans, scale) => transform(shape, concat([], tmat([], postTrans), smat([], scale), tmat([], preTrans)));
const fitIntoBounds2 = (shape, dest) => {
    const src = bounds(shape);
    if (!src)
        return;
    const c = centroid(src);
    if (!c)
        return;
    return translateScale(translation23, scale23, shape, neg(null, c), centroid(dest), minNonZero2(safeDiv(dest.size[0], src.size[0]), safeDiv(dest.size[1], src.size[1])));
};
const fitIntoBounds3 = (shape, dest) => {
    const src = bounds(shape);
    if (!src)
        return;
    const c = centroid(src);
    if (!c)
        return;
    return translateScale(translation44, scale44, shape, neg(null, c), centroid(dest), minNonZero3(safeDiv(dest.size[0], src.size[0]), safeDiv(dest.size[1], src.size[1]), safeDiv(dest.size[2], src.size[2])));
};
const fitAllIntoBounds2 = (shapes, dest) => {
    const sbraw = __collBounds(shapes, bounds);
    if (!sbraw)
        return;
    const src = new Rect(...sbraw);
    const sx = safeDiv(dest.size[0], src.size[0]);
    const sy = safeDiv(dest.size[1], src.size[1]);
    const scale = sx > 0 ? (sy > 0 ? Math.min(sx, sy) : sx) : sy;
    const smat = scale23([], scale);
    const b = center(transform(src, smat), centroid(dest));
    const c1 = [];
    const c2 = [];
    const res = [];
    for (let i = shapes.length; --i >= 0;) {
        const s = shapes[i];
        const sc = centroid(s, c1);
        if (sc) {
            unmapPoint(b, mapPoint(src, sc), c2);
            res.push(translateScale(translation23, scale23, s, neg(null, c1), c2, smat));
        }
        else {
            res.push(s);
        }
    }
    return res;
};

const flip = defmulti(__dispatch, {
    cubic: "points",
    line: "points",
    points3: "points",
    poly: "points",
    polyline: "points",
    quad: "points",
    quadratic: "points",
    tri: "points",
}, {
    [DEFAULT]: (x) => x,
    arc: ($) => {
        const t = $.start;
        $.start = $.end;
        $.end = t;
        $.cw = !$.cw;
        return $;
    },
    group: ($) => {
        $.children.forEach(flip);
        return $;
    },
    path: ($) => {
        // TODO
        return $;
    },
    points: ($) => {
        $.points.reverse();
        return $;
    },
    ray: ($) => {
        $.dir = neg(null, $.dir);
        return $;
    },
});

const intersects = defmulti(__dispatch2, {
    "ray-sphere": "ray-circle",
    "ray-quad": "ray-poly",
    "ray-tri": "ray-poly",
    "sphere-sphere": "circle-circle",
}, {
    "circle-circle": (a, b) => intersectCircleCircle(a.pos, b.pos, a.r, b.r),
    "line-line": ({ points: a }, { points: b }) => intersectLineLine(a[0], a[1], b[0], b[1]),
    "plane-plane": (a, b) => intersectPlanePlane(a.normal, a.w, b.normal, b.w),
    "ray-aabb": (ray, box) => intersectRayAABB(ray.pos, ray.dir, box.pos, box.max()),
    "ray-circle": (ray, sphere) => intersectRayCircle(ray.pos, ray.dir, sphere.pos, sphere.r),
    "ray-plane": (ray, plane) => intersectRayPlane(ray.pos, ray.dir, plane.normal, plane.w),
    "ray-poly": (ray, poly) => intersectRayPolyline(ray.pos, ray.dir, poly.points, true),
    "ray-polyline": (ray, poly) => intersectRayPolyline(ray.pos, ray.dir, poly.points, false),
    "ray-rect": (ray, rect) => intersectRayRect(ray.pos, ray.dir, rect.pos, rect.max()),
    "rect-circle": (rect, circle) => ({
        type: testRectCircle(rect.pos, rect.size, circle.pos, circle.r)
            ? IntersectionType.INTERSECT
            : IntersectionType.NONE,
    }),
    "rect-rect": (a, b) => ({
        type: testRectRect(a.pos, a.size, b.pos, b.size)
            ? IntersectionType.INTERSECT
            : IntersectionType.NONE,
    }),
});

const offset = defmulti(__dispatch, {}, {
    circle: ($, n) => new Circle(set2([], $.pos), Math.max($.r + n, 0)),
    line: ({ points: [a, b], attribs }, n) => {
        const norm = normalCW([], a, b, n);
        return new Quad([
            add2([], a, norm),
            add2([], b, norm),
            sub2([], b, norm),
            sub2([], a, norm),
        ], { ...attribs });
    },
    rect: ($, n) => rectFromCentroid(centroid($), max2(null, addN2([], $.size, n), ZERO2), __copyAttribs($)),
});

const pointAt = defmulti(__dispatch, {
    quad: "poly",
    tri: "poly",
}, {
    arc: ($, t) => $.pointAtTheta(fit01(t, $.start, $.end)),
    circle: ($, t) => cartesian2(null, [$.r, TAU * t], $.pos),
    cubic: ({ points }, t) => mixCubic([], points[0], points[1], points[2], points[3], t),
    ellipse: ($, t) => madd2([], cossin(TAU * t), $.r, $.pos),
    line: ({ points }, t) => mixN2([], points[0], points[1], t),
    poly: ($, t) => new Sampler($.points, true).pointAt(t),
    polyline: ($, t) => new Sampler($.points).pointAt(t),
    quadratic: ({ points }, t) => mixQuadratic([], points[0], points[1], points[2], t),
    ray: ($, t) => pointOnRay2([], $.pos, $.dir, t),
    ray3: ($, t) => pointOnRay3([], $.pos, $.dir, t),
    rect: ($, t) => new Sampler(vertices($), true).pointAt(t),
});

const pointInside = defmulti(__dispatch, {
    points3: "points",
    quad: "poly",
    sphere: "circle",
}, {
    aabb: ($, p) => pointInAABB(p, $.pos, $.size),
    circle: ($, p) => pointInCircle(p, $.pos, $.r),
    line: ($, p) => pointInSegment(p, $.points[0], $.points[1]),
    points: ({ points }, p) => isInArray(p, points),
    poly: ($, p) => pointInPolygon2(p, $.points) > 0,
    rect: ($, p) => pointInRect(p, $.pos, $.size),
    tri: (tri, p) => pointInTriangle2(p, ...tri.points),
});

const resample = defmulti(__dispatch, {
    ellipse: "circle",
    line: "polyline",
    quad: "poly",
    tri: "poly",
    rect: "circle",
}, {
    circle: ($, opts) => asPolygon($, opts),
    poly: ($, opts) => new Polygon(resample$1($.points, opts, true, true), __copyAttribs($)),
    polyline: ($, opts) => new Polyline(resample$1($.points, opts, false, true), __copyAttribs($)),
});

const scatter = (shape, num, rnd = SYSTEM, out = []) => {
    const b = bounds(shape);
    if (!b)
        return;
    const mi = b.pos;
    const mx = b.max();
    for (; --num >= 0;) {
        while (true) {
            const p = randMinMax([], mi, mx, rnd);
            if (pointInside(shape, p)) {
                out.push(p);
                break;
            }
        }
    }
    return out;
};

const simplify = defmulti(__dispatch, {}, {
    path: ($, eps = 0.1) => {
        const res = [];
        const orig = $.segments;
        const n = orig.length;
        let points;
        let lastP;
        for (let i = 0; i < n; i++) {
            const s = orig[i];
            if (s.type === "l" || s.type === "p") {
                points = points
                    ? points.concat(vertices(s.geo))
                    : vertices(s.geo);
                lastP = peek(points);
            }
            else if (points) {
                points.push(lastP);
                res.push({
                    geo: new Polyline(simplify$1(points, eps)),
                    type: "p",
                });
                points = null;
            }
            else {
                res.push({ ...s });
            }
        }
        if (points) {
            points.push(lastP);
            res.push({
                geo: new Polyline(points),
                type: "p",
            });
        }
        return new Path(res, __copyAttribs($));
    },
    poly: ($, eps = 0.1) => new Polygon(simplify$1($.points, eps, true), __copyAttribs($)),
    polyline: ($, eps = 0.1) => new Polyline(simplify$1($.points, eps), __copyAttribs($)),
});

const __pointArraysAsShapes = (ctor, src, attribs) => src
    ? [...map((pts) => new ctor(copyVectors(pts), { ...attribs }), src)]
    : undefined;

const __splitLine = (a, b, t) => {
    const p = mixN([], a, b, t);
    return [
        [a, p],
        [set([], p), b],
    ];
};

const splitAt = defmulti(__dispatch, {}, {
    arc: ($, t) => {
        const theta = fit01(t, $.start, $.end);
        return [
            new Arc(set([], $.pos), set([], $.r), $.axis, $.start, theta, $.xl, $.cw, __copyAttribs($)),
            new Arc(set([], $.pos), set([], $.r), $.axis, theta, $.end, $.xl, $.cw, __copyAttribs($)),
        ];
    },
    cubic: ({ attribs, points }, t) => cubicSplitAt(points[0], points[1], points[2], points[3], t).map((pts) => new Cubic(pts, { ...attribs })),
    line: ({ attribs, points }, t) => __splitLine(points[0], points[1], t).map((pts) => new Line(pts, { ...attribs })),
    polyline: ($, t) => __pointArraysAsShapes(Polyline, new Sampler($.points).splitAt(t), $.attribs),
    quadratic: ({ attribs, points }, t) => quadraticSplitAt(points[0], points[1], points[2], t).map((pts) => new Quadratic(pts, { ...attribs })),
});

/**
 * Similar to {@link splitAt}, but instead of taking a normalized parametric
 * split position, splits the given curve at the closest point to `p`.
 * Returns tuple of split shapes of same type as `shape`.
 *
 * Implemented for:
 *
 * - Cubic
 * - Line
 * - Polyline
 * - Quadratic
 *
 * @param shape - shape to operate on
 * @param p - split point
 */
const splitNearPoint = defmulti(__dispatch, {}, {
    cubic: ({ points, attribs }, p) => splitCubicNearPoint(p, points[0], points[1], points[2], points[3]).map((pts) => new Cubic(pts, { ...attribs })),
    line: ($, p) => {
        const t = closestT(p, $.points[0], $.points[1]) || 0;
        return __splitLine($.points[0], $.points[1], clamp01(t)).map((pts) => new Line(pts, __copyAttribs($)));
    },
    polyline: ($, p) => __pointArraysAsShapes(Polyline, new Sampler($.points).splitNear(p), $.attribs),
    quadratic: ({ points, attribs }, p) => quadraticSplitNearPoint(p, points[0], points[1], points[2]).map((pts) => new Quadratic(pts, { ...attribs })),
});

const subdivCurve = defmulti(__dispatch, {}, {
    poly: ($, kernel, iter = 1) => new Polygon(subdivide($.points, kernel, iter), __copyAttribs($)),
    polyline: ($, kernel, iter = 1) => new Polyline(subdivide($.points, kernel, iter), __copyAttribs($)),
});

const tangentAt = defmulti(__dispatch, {
    quad: "poly",
    tri: "poly",
}, {
    circle: (_, t) => cossin(TAU * t + HALF_PI),
    cubic: ({ points }, t) => cubicTangentAt([], points[0], points[1], points[2], points[3], t),
    line: ({ points }) => direction([], points[0], points[1]),
    poly: ($, t) => new Sampler($.points, true).tangentAt(t),
    polyline: ($, t) => new Sampler($.points).tangentAt(t),
    quadratic: ({ points }, t) => quadraticTangentAt([], points[0], points[1], points[2], t),
    rect: ($, t) => new Sampler(vertices($), true).tangentAt(t),
});

const tessellate = defmulti(__dispatch, {}, {
    [DEFAULT]: ($, fns) => tessellate$1(vertices($), fns),
});

/**
 * Transforms vertices of given shape with provided function, which is
 * being called for each vertex individually and should produce a
 * transformation matrix. Some shape types will be automatically
 * converted to other types prior to transformation because they cannot
 * be reliably represented in their original type anymore, this
 * includes:
 *
 * - Arc => Path (cubics)
 * - Circle => Path (cubics)
 * - Ellipse => Path (cubics)
 * - Rect => Polygon
 */
const transformVertices = defmulti(__dispatch, {
    circle: "rect",
    ellipse: "circle",
}, {
    arc: ($, fn) => transformVertices(asPolyline($), fn),
    cubic: __transformedShapePoints(Cubic),
    group: ($, fn) => $.copyTransformed((x) => transformVertices(x, fn)),
    line: __transformedShapePoints(Line),
    path: ($, fn) => new Path([
        ...map((s) => s.type === "m"
            ? {
                type: s.type,
                point: mulV([], fn(s.point), s.point),
            }
            : {
                type: s.type,
                geo: transformVertices(s.geo, fn),
            }, $.segments),
    ], __copyAttribs($)),
    points: __transformedShapePoints(Points),
    points3: __transformedShapePoints3(Points3),
    poly: __transformedShapePoints(Polygon),
    polyline: __transformedShapePoints(Polyline),
    quad: __transformedShapePoints(Quad),
    quadratic: __transformedShapePoints(Quadratic),
    rect: ($, fn) => transformVertices(asPolygon($), fn),
    tri: __transformedShapePoints(Triangle),
});

const union = defmulti(__dispatch, {}, {
    aabb: (a, b) => [
        new AABB(...__unionBounds(a.pos, a.size, b.pos, b.size)),
    ],
    rect: (a, b) => [
        new Rect(...__unionBounds(a.pos, a.size, b.pos, b.size)),
    ],
});

/**
 * Returns the volume of given 3D shape. Returns 0 for all others.
 *
 * Currently only implemented for:
 *
 * - AABB
 * - Sphere
 */
const volume = defmulti(__dispatch, {}, {
    [DEFAULT]: () => 0,
    aabb: ({ size }) => size[0] * size[1] * size[2],
    sphere: ($) => (4 / 3) * PI * $.r ** 3,
});

const warpPoints = (pts, dest, src) => {
    const res = [];
    for (let n = pts.length, i = 0; i < n; i++) {
        res.push(unmapPoint(dest, mapPoint(src, pts[i])));
    }
    return res;
};

const withAttribs = (shape, attribs, replace = true) => {
    shape.attribs = replace ? attribs : { ...shape.attribs, ...attribs };
    return shape;
};

export { AABB, Arc, Cubic, Ellipse, Group, Line, Path, PathBuilder, Plane, Points, Points3, Polyline, Quad, Quad3, Quadratic, Ray, Rect, Sphere, Text, Triangle, aabb, aabbFromMinMax, arc, arcFrom2Points, arcLength, area, asCubic, asPath, asPolyline, asSvg, bounds, center, centroid, classifyPoint, clipConvex, clippedLine, closestPoint, convexHull, cubic, cubicFromArc, cubicFromLine, cubicFromQuadratic, edges, ellipse, equilateralTriangle, fitAllIntoBounds2, fitIntoBounds2, fitIntoBounds3, flip, group, inscribedAABB, inscribedSquare, inscribedSquareHex, intersectionAABB, intersectionRect, intersects, line, mapPoint, normalizedPath, offset, path, pathBuilder, pathFromCubics, pathFromSvg, plane, planeFrom3Points, planeWithPoint, pointAt, pointInside, points, points3, polygon, polyline, quad, quad3, quadOnPlane, quadratic, quadraticFromLine, ray, rect, rectFromCentroid, rectFromMinMax, resample, roundedRect, scatter, simplify, splitAt, splitNearPoint, star, subdivCurve, svgDoc, tangentAt, tessellate, text, transform, transformVertices, translate, triangle, union, unmapPoint, volume, warpPoints, withAttribs };

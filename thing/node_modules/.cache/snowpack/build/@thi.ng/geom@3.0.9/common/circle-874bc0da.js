import { circumCenter2 } from '@thi.ng/geom-poly-utils/circumcenter';
import { dist } from '@thi.ng/vectors/dist';
import { mixN2 } from '@thi.ng/vectors/mixn';
import { set } from '@thi.ng/vectors/set';
import { _ as __copyAttribs } from './copy-83b50873.js';
import { peek } from '@thi.ng/arrays/peek';
import { isNumber } from '@thi.ng/checks/is-number';
import { isPlainObject } from '@thi.ng/checks/is-plain-object';

class Circle {
    constructor(pos = [0, 0], r = 1, attribs) {
        this.pos = pos;
        this.r = r;
        this.attribs = attribs;
    }
    get type() {
        return "circle";
    }
    copy() {
        return new Circle(set([], this.pos), this.r, __copyAttribs(this));
    }
    toHiccup() {
        return ["circle", this.attribs, this.pos, this.r];
    }
}

/**
 * Takes an array of arguments, checks if last element is a plain object
 * and if so, removes it from array and returns it. Else returns
 * `undefined`.
 *
 * @param args -
 *
 * @internal
 */
const __argAttribs = (args) => isPlainObject(peek(args)) ? args.pop() : undefined;
/**
 * Args parser for functions expecting up to 2 vector args and optional
 * attribs object. Returns 3-tuple of re-structured args.
 *
 * @param args -
 *
 * @internal
 */
const __argsVV = (args) => {
    const attr = __argAttribs(args);
    return args.length
        ? args.length === 2
            ? [args[0], args[1], attr]
            : [undefined, args[0], attr]
        : [undefined, undefined, attr];
};
/**
 * Args parser for functions expecting a vector, numeric and/or optional
 * attribs object. Returns 3-tuple of re-structured args.
 *
 * @param args -
 *
 * @internal
 */
const __argsVN = (args) => {
    const attr = __argAttribs(args);
    return args.length
        ? args.length === 2
            ? [args[0], args[1], attr]
            : isNumber(args[0])
                ? [undefined, args[0], attr]
                : [args[0], undefined, attr]
        : [undefined, undefined, attr];
};

function circle(...args) {
    return new Circle(...__argsVN(args));
}
const circleFrom2Points = (a, b, attribs) => new Circle(mixN2([], a, b, 0.5), dist(a, b) / 2, attribs);
const circleFrom3Points = (a, b, c, attribs) => {
    const o = circumCenter2(a, b, c);
    return o ? new Circle(o, dist(a, o), attribs) : undefined;
};

export { Circle as C, __argsVV as _, __argAttribs as a, circleFrom2Points as b, circle as c, circleFrom3Points as d };

import { defmulti } from '@thi.ng/defmulti/defmulti';
import { a as __copyShape, _ as __copyAttribs } from './copy-83b50873.js';
import { isArray } from '@thi.ng/checks/is-array';
import { isNumber } from '@thi.ng/checks/is-number';
import { DEFAULT_SAMPLES } from '@thi.ng/geom-api/sample';
import { sample } from '@thi.ng/geom-arc/sample';
import { resample } from '@thi.ng/geom-resample/resample';
import { sampleCubic } from '@thi.ng/geom-splines/cubic-sample';
import { sampleQuadratic } from '@thi.ng/geom-splines/quadratic-sample';
import { cossin } from '@thi.ng/math/angle';
import { TAU } from '@thi.ng/math/api';
import { add3, add2 } from '@thi.ng/vectors/add';
import { cartesian2 } from '@thi.ng/vectors/cartesian';
import { madd2 } from '@thi.ng/vectors/madd';
import { set2 } from '@thi.ng/vectors/set';

class APC {
    constructor(points = [], attribs) {
        this.points = points;
        this.attribs = attribs;
    }
    *[Symbol.iterator]() {
        yield* this.points;
    }
}

class Polygon extends APC {
    get type() {
        return "poly";
    }
    copy() {
        return __copyShape(Polygon, this);
    }
    toHiccup() {
        return ["polygon", this.attribs, this.points];
    }
}

const __dispatch = (x) => x.type;
const __dispatch2 = (a, b) => a.type + "-" + b.type;

const vertices = defmulti(__dispatch, {
    line: "polyline",
    points3: "points",
    quad: "poly",
    tri: "poly",
}, {
    // e +----+ h
    //   |\   :\
    //   |f+----+ g
    //   | |  : |
    // a +-|--+d|
    //    \|   \|
    //   b +----+ c
    //
    aabb: ({ pos, size }) => {
        const [px, py, pz] = pos;
        const [qx, qy, qz] = add3([], pos, size);
        return [
            [px, py, pz],
            [px, py, qz],
            [qx, py, qz],
            [qx, py, pz],
            [px, qy, pz],
            [px, qy, qz],
            [qx, qy, qz],
            [qx, qy, pz], // h
        ];
    },
    arc: ($, opts) => sample($.pos, $.r, $.axis, $.start, $.end, opts),
    circle: ($, opts = DEFAULT_SAMPLES) => {
        const pos = $.pos;
        const r = $.r;
        let [num, last] = circleOpts(opts, r);
        const delta = TAU / num;
        last && num++;
        const buf = new Array(num);
        for (let i = 0; i < num; i++) {
            buf[i] = cartesian2(null, [r, i * delta], pos);
        }
        return buf;
    },
    cubic: ($, opts) => sampleCubic($.points, opts),
    ellipse: ($, opts = DEFAULT_SAMPLES) => {
        const buf = [];
        const pos = $.pos;
        const r = $.r;
        let [num, last] = circleOpts(opts, Math.max($.r[0], $.r[1]));
        const delta = TAU / num;
        last && num++;
        for (let i = 0; i < num; i++) {
            buf[i] = madd2([], cossin(i * delta), r, pos);
        }
        return buf;
    },
    group: ({ children }) => children.reduce((acc, $) => acc.concat(vertices($)), []),
    path: ($, opts) => {
        const _opts = isNumber(opts) ? { num: opts } : opts;
        let verts = [];
        for (let segs = $.segments, n = segs.length - 1, i = 0; i <= n; i++) {
            const s = segs[i];
            if (s.geo) {
                verts = verts.concat(vertices(s.geo, {
                    ..._opts,
                    last: i === n && !$.closed,
                }));
            }
        }
        return verts;
    },
    points: ($) => $.points,
    poly: ($, opts) => resample($.points, opts, true),
    polyline: ($, opts) => resample($.points, opts),
    quadratic: ($, opts) => sampleQuadratic($.points, opts),
    rect: ($, opts) => {
        const p = $.pos;
        const q = add2([], p, $.size);
        const verts = [set2([], p), [q[0], p[1]], q, [p[0], q[1]]];
        return opts != null ? vertices(new Polygon(verts), opts) : verts;
    },
});
/**
 * Takes array of vectors or an `IShape`. If the latter, calls {@link vertices}
 * and return result, else returns original array.
 *
 * @param shape
 */
const ensureVertices = (shape) => isArray(shape) ? shape : vertices(shape);
const circleOpts = (opts, r) => isNumber(opts)
    ? [opts, false]
    : [
        opts.theta
            ? Math.floor(TAU / opts.theta)
            : opts.dist
                ? Math.floor(TAU / (opts.dist / r))
                : opts.num || DEFAULT_SAMPLES,
        opts.last === true,
    ];

const asPolygon = defmulti(__dispatch, {
    circle: "points",
    ellipse: "points",
    line: "points",
    path: "points",
    poly: "points",
    polyline: "points",
    quad: "points",
    rect: "points",
    tri: "points",
}, {
    points: ($, opts) => new Polygon(vertices($, opts), __copyAttribs($)),
});

export { APC as A, Polygon as P, __dispatch as _, asPolygon as a, __dispatch2 as b, ensureVertices as e, vertices as v };

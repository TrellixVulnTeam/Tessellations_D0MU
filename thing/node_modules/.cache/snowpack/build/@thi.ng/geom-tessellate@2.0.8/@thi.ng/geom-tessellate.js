export { tessellate } from './geom-tessellate/tessellate.js';
import { pointInTriangle2 } from '@thi.ng/geom-isec/point';
import { polyArea2 } from '@thi.ng/geom-poly-utils/area';
import { range } from '@thi.ng/transducers/range';
import { signedArea2 } from '@thi.ng/vectors/signed-area';
import { centroid } from '@thi.ng/geom-poly-utils/centroid';
import { comp } from '@thi.ng/transducers/comp';
import { mapcat } from '@thi.ng/transducers/mapcat';
import { partition } from '@thi.ng/transducers/partition';
import { push } from '@thi.ng/transducers/push';
import { transduce } from '@thi.ng/transducers/transduce';
import { wrapSides } from '@thi.ng/transducers/wrap-sides';
import { mixN } from '@thi.ng/vectors/mixn';
import { map } from '@thi.ng/transducers/map';
import { zip } from '@thi.ng/transducers/zip';
import '@thi.ng/checks/is-function';
import '@thi.ng/transducers/last';
import '@thi.ng/transducers/reduce';
import '@thi.ng/transducers/repeat';
import '@thi.ng/transducers/scan';

const snip = (points, u, v, w, n, ids) => {
    const a = points[ids[u]];
    const b = points[ids[v]];
    const c = points[ids[w]];
    if (signedArea2(a, b, c) > 0) {
        for (let i = 0; i < n; i++) {
            if (i !== u && i !== v && i !== w) {
                if (pointInTriangle2(points[ids[i]], a, b, c)) {
                    return;
                }
            }
        }
        return [a, b, c];
    }
};
/**
 * Tessellator for simple 2D polygons.
 *
 * @param points - polygon vertices
 */
const earCut2 = (points) => {
    const tris = [];
    let n = points.length;
    const ids = [...(polyArea2(points) > 0 ? range(n) : range(n - 1, -1, -1))];
    let count = 2 * n - 1;
    let v = n - 1, u, w, t;
    while (count > 0 && n > 2) {
        u = n <= v ? 0 : v;
        v = u + 1;
        v = n <= v ? 0 : v;
        w = v + 1;
        w = n <= w ? 0 : w;
        t = snip(points, u, v, w, n, ids);
        if (t !== undefined) {
            tris.push(t);
            ids.splice(v, 1);
            n--;
            count = 2 * n;
        }
        else {
            count--;
        }
    }
    return tris;
};

const edgeSplit = (points) => {
    const c = centroid(points);
    return transduce(comp(partition(2, 1), mapcat(([a, b]) => {
        const m = mixN([], a, b, 0.5);
        return [
            [a, m, c],
            [m, b, c],
        ];
    })), push(), wrapSides(points, 0, 1));
};

const tesselInset = (inset = 0.5, keepInterior = false) => (points) => {
    const c = centroid(points);
    const inner = points.map((p) => mixN([], p, c, inset));
    return transduce(comp(partition(2, 1), map(([[a, b], [c, d]]) => [a, b, d, c])), push(), keepInterior ? [inner] : [], wrapSides([...zip(points, inner)], 0, 1));
};

const quadFan = (points) => {
    const p = centroid(points);
    return transduce(comp(partition(3, 1), map(([a, b, c]) => [mixN([], a, b, 0.5), b, mixN([], b, c, 0.5), p])), push(), wrapSides(points));
};

const rimTris = (points) => {
    const edgeCentroids = transduce(comp(partition(2, 1), map((e) => mixN([], e[0], e[1], 0.5))), push(), wrapSides(points, 0, 1));
    return transduce(comp(partition(2, 1), map((t) => [t[0][0], t[1][1], t[1][0]])), push(), [edgeCentroids], wrapSides([...zip(edgeCentroids, points)], 1, 0));
};

const triFan = (points) => {
    const c = centroid(points);
    return transduce(comp(partition(2, 1), map(([a, b]) => [a, b, c])), push(), wrapSides(points, 0, 1));
};

export { earCut2, edgeSplit, quadFan, rimTris, tesselInset, triFan };

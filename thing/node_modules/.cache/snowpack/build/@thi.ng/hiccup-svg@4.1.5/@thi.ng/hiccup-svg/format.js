import { isArrayLike } from '@thi.ng/checks/is-arraylike';
import { isString } from '@thi.ng/checks/is-string';
import { css } from '@thi.ng/color/css/css';

let PRECISION = 2;
const setPrecision = (n) => (PRECISION = n);
/** @internal */
const ff = (x) => (x === (x | 0) ? x : x.toFixed(PRECISION));
/** @internal */
const fpoint = (p) => ff(p[0]) + "," + ff(p[1]);
/** @internal */
const fpoints = (pts, sep = " ") => pts ? pts.map(fpoint).join(sep) : "";
const DEFAULT_NUMERIC_IDS = [
    "font-size",
    "opacity",
    "stroke-width",
    "stroke-miterlimit",
];
/**
 * Takes an attributes object and a number of attrib IDs whose values should be
 * formatted using {@link ff}. Mutates and returns `attribs` object.
 *
 * @param attribs
 * @param ids
 *
 * @internal
 */
const numericAttribs = (attribs, ids) => {
    let v;
    for (let id of DEFAULT_NUMERIC_IDS.concat(ids)) {
        typeof (v = attribs[id]) === "number" && (attribs[id] = ff(v));
    }
    return attribs;
};
/**
 * Takes an attributes object and converts any `fill`, `stroke` or
 * transformation attributes, i.e. `transform`, `rotate`, `scale`, `translate`.
 *
 * @remarks
 * If the element has a `transform` attrib, conversion of the other attribs will
 * be skipped, else the values are assumed to be either strings or:
 *
 * - `transform`: 6-element numeric array (mat23)
 * - `translate`: 2-element array
 * - `rotate`: number (angle in radians)
 * - `scale`: number (uniform scale) or 2-elem array
 *
 * If no `transform` is given, the resulting transformation order will always be
 * TRS. Any string values given will be used as-is and therefore need to be
 * complete, e.g. `{ rotate: "rotate(60)" }`
 *
 * For color related attribs (`fill`, `stroke`), if given value is array-like, a
 * number or an {@link @thi.ng/color#IColor} instance, it will be converted into
 * a CSS color string using {@link @thi.ng/color#asCSS}.
 *
 * String color attribs prefixed with `$` are replaced with `url(#...)` refs
 * (used for referencing gradients).
 *
 * Additional attribute names given (via rest args) will be formatted as numeric
 * values (using configured precision, see {@link setPrecision}). Formatting is
 * done via {@link numericAttribs}.
 *
 * Returns updated attribs or `undefined` if `attribs` itself is null-ish.
 *
 * @param attribs - attributes object
 * @param numericIDs - numeric attribute names
 *
 * @internal
 */
const fattribs = (attribs, ...numericIDs) => {
    if (!attribs)
        return;
    const res = ftransforms(attribs);
    let v;
    (v = attribs.fill) && (res.fill = fcolor(v));
    (v = attribs.stroke) && (res.stroke = fcolor(v));
    return numericAttribs(attribs, numericIDs);
};
/**
 * Converts any transformation related attribs.
 *
 * {@link fattribs}
 *
 * @param attribs - attributes object
 *
 * @internal
 */
const ftransforms = (attribs) => {
    let v;
    if ((v = attribs.transform) ||
        attribs.translate ||
        attribs.scale ||
        attribs.rotate) {
        if (v) {
            attribs.transform = !isString(v)
                ? `matrix(${[...v].map(ff).join(" ")})`
                : v;
            delete attribs.translate;
            delete attribs.rotate;
            delete attribs.scale;
        }
        else {
            attribs.transform = buildTransform(attribs);
        }
    }
    return attribs;
};
/**
 * @internal
 */
const buildTransform = (attribs) => {
    const tx = [];
    let v;
    if ((v = attribs.translate)) {
        tx.push(isString(v) ? v : `translate(${ff(v[0])} ${ff(v[1])})`);
        delete attribs.translate;
    }
    if ((v = attribs.rotate)) {
        tx.push(isString(v) ? v : `rotate(${ff((v * 180) / Math.PI)})`);
        delete attribs.rotate;
    }
    if ((v = attribs.scale)) {
        tx.push(isString(v)
            ? v
            : isArrayLike(v)
                ? `scale(${ff(v[0])} ${ff(v[1])})`
                : `scale(${ff(v)})`);
        delete attribs.scale;
    }
    return tx.join(" ");
};
/**
 * Attempts to convert a single color attrib value. If `col` is prefixed with
 * `$`, the value will be converted into a `url(#...)` reference.
 *
 * {@link fattribs}
 *
 * @param col - color value
 *
 * @internal
 */
const fcolor = (col) => isString(col)
    ? col[0] === "$"
        ? `url(#${col.substr(1)})`
        : col
    : css(col);
/** @internal */
const withoutKeys = (src, keys) => {
    const dest = {};
    for (let k in src) {
        src.hasOwnProperty(k) && !keys.has(k) && (dest[k] = src[k]);
    }
    return dest;
};

export { fattribs, fcolor, ff, fpoint, fpoints, setPrecision, withoutKeys };

import { implementsFunction } from '@thi.ng/checks/implements-function';
import { isArray } from '@thi.ng/checks/is-array';
import { fattribs, ff, fcolor, fpoints, fpoint, withoutKeys } from './format.js';
import '@thi.ng/checks/is-arraylike';
import '@thi.ng/checks/is-string';
import '@thi.ng/color/css/css';

const circle = (p, r, attribs, ...body) => [
    "circle",
    fattribs({
        ...attribs,
        cx: ff(p[0]),
        cy: ff(p[1]),
        r: ff(r),
    }),
    ...body,
];

const ellipse = (p, rx, ry, attribs, ...body) => [
    "ellipse",
    fattribs({
        ...attribs,
        cx: ff(p[0]),
        cy: ff(p[1]),
        rx: ff(rx),
        ry: ff(ry),
    }),
    ...body,
];

const RE_ALPHA_COLOR = /(rgb|hsl)a\(([a-z0-9.-]+),([0-9.%]+),([0-9.%]+),([0-9.]+)\)/;
const gradient = (type, attribs, stops) => [
    type,
    fattribs(attribs),
    ...stops.map(gradientStop),
];
const gradientStop = ([offset, col]) => {
    col = fcolor(col);
    // use stop-opacity attrib for safari compatibility
    // https://stackoverflow.com/a/26220870/294515
    let opacity;
    const parts = RE_ALPHA_COLOR.exec(col);
    if (parts) {
        col = `${parts[1]}(${parts[2]},${parts[3]},${parts[4]})`;
        opacity = parts[5];
    }
    return ["stop", { offset, "stop-color": col, "stop-opacity": opacity }];
};
const linearGradient = (id, from, to, stops, attribs) => gradient("linearGradient", {
    ...attribs,
    id,
    x1: ff(from[0]),
    y1: ff(from[1]),
    x2: ff(to[0]),
    y2: ff(to[1]),
}, stops);
const radialGradient = (id, from, to, fr, r, stops, attribs) => gradient("radialGradient", {
    ...attribs,
    id,
    fx: ff(from[0]),
    fy: ff(from[1]),
    cx: ff(to[0]),
    cy: ff(to[1]),
    fr: ff(fr),
    r: ff(r),
}, stops);

const image = (pos, url, attribs, ...body) => [
    "image",
    fattribs({
        ...attribs,
        // TODO replace w/ SVG2 `href` once Safari supports it
        "xlink:href": url,
        x: ff(pos[0]),
        y: ff(pos[1]),
    }),
    ...body,
];

const line = (a, b, attribs, ...body) => [
    "line",
    fattribs({
        ...attribs,
        x1: ff(a[0]),
        y1: ff(a[1]),
        x2: ff(b[0]),
        y2: ff(b[1]),
    }),
    ...body,
];
const hline = (y, attribs) => line([-1e6, y], [1e6, y], attribs);
const vline = (x, attribs) => line([x, -1e6], [x, 1e6], attribs);

const DEG = 180 / Math.PI;
const path = (segments, attribs, ...body) => {
    let res = [];
    for (let seg of segments) {
        res.push(seg[0]);
        switch (seg[0].toLowerCase()) {
            case "a":
                res.push([
                    // rx
                    ff(seg[1]),
                    // ry
                    ff(seg[2]),
                    // x-axis (theta)
                    ff(seg[3] * DEG),
                    // xl
                    seg[4] ? 1 : 0,
                    // clockwise
                    seg[5] ? 1 : 0,
                    // target xy
                    ff(seg[6][0]),
                    ff(seg[6][1]),
                ].join(","));
                break;
            case "h":
            case "v":
                res.push(ff(seg[1]));
                break;
            case "m":
            case "l":
                res.push(fpoint(seg[1]));
                break;
            case "z":
                break;
            default:
                res.push(fpoints(seg.slice(1), ","));
        }
    }
    return ["path", fattribs({ ...attribs, d: res.join("") }), ...body];
};

/**
 * Shape instancing group.
 *
 * @remarks
 * The `shape` arg can be an SVG shape `#id` defined elsewhere in the
 * document or set to `circle` or `rect` (default).
 *
 * The `size` arg is only used for the latter two shape types and
 * defines the radius or width respectively.
 *
 * @param pts - points
 * @param shape - shape type
 * @param size - point size/radius
 * @param attribs - attributes
 */
const points = (pts, shape, size = 1, attribs, ...body) => {
    const group = [
        "g",
        fattribs(withoutKeys(attribs, new Set(["shape", "size"]))),
        ...body,
    ];
    const href = buildSymbol(group, shape, size);
    for (let p of pts) {
        // TODO replace w/ SVG2 `href` once Safari supports it
        group.push(["use", { "xlink:href": href, x: ff(p[0]), y: ff(p[1]) }]);
    }
    return group;
};
/**
 * Similar to {@link points}, but takes points from a single large flat
 * buffer of coordinates with arbitrary striding.
 *
 * @remarks
 * In addition to `shape` and `size`, the following attribs can be used
 * to define the index range and strides:
 *
 * - `start` - start index (default: 0)
 * - `num` - number of points (default: buffer length/2)
 * - `cstride` - component stride (default: 1)
 * - `estride` - element stride (default: 2)
 *
 * @param pts - flat point buffer
 * @param shape - shape type
 * @param size - point size/radius
 * @param attribs - other attributes
 */
const packedPoints = (pts, shape, size = 1, attribs, ...body) => {
    attribs = {
        start: 0,
        cstride: 1,
        estride: 2,
        ...attribs,
    };
    const { start, cstride, estride } = attribs;
    let num = attribs && attribs.num != null
        ? attribs.num
        : ((pts.length - start) / estride) | 0;
    const group = [
        "g",
        fattribs(withoutKeys(attribs, new Set(["start", "cstride", "estride", "shape", "size", "num"]))),
        ...body,
    ];
    const href = buildSymbol(group, shape, size);
    for (let i = start; --num >= 0; i += estride) {
        // TODO replace w/ SVG2 `href` once Safari supports it
        group.push([
            "use",
            { "xlink:href": href, x: ff(pts[i]), y: ff(pts[i + cstride]) },
        ]);
    }
    return group;
};
const buildSymbol = (group, shape, size) => {
    let href;
    if (!shape || shape[0] !== "#") {
        href = "_" + ((Math.random() * 1e6) | 0).toString(36);
        group.push(["g", { opacity: 0 }, buildShape(shape, href, size)]);
        href = "#" + href;
    }
    else {
        href = shape;
    }
    return href;
};
const buildShape = (shape, id, r) => {
    const rf = ff(r);
    if (shape === "circle") {
        return ["circle", { id, cx: 0, cy: 0, r: rf }];
    }
    const rf2 = ff(-r / 2);
    return ["rect", { id, x: rf2, y: rf2, width: rf, height: rf }];
};

const polygon = (pts, attribs, ...body) => [
    "polygon",
    fattribs({
        ...attribs,
        points: fpoints(pts),
    }),
    ...body,
];

const polyline = (pts, attribs, ...body) => [
    "polyline",
    fattribs({
        fill: "none",
        points: fpoints(pts),
        ...attribs,
    }),
    ...body,
];

const roundedRect = (p, width, height, rx, ry, attribs, ...body) => {
    attribs = fattribs({
        ...attribs,
        x: ff(p[0]),
        y: ff(p[1]),
        width: ff(width),
        height: ff(height),
    });
    if (rx > 0 || ry > 0) {
        attribs.rx = ff(rx);
        attribs.ry = ff(ry);
    }
    return ["rect", attribs, ...body];
};

const text = (p, body, attribs, ...xs) => [
    "text",
    fattribs({
        ...attribs,
        x: ff(p[0]),
        y: ff(p[1]),
    }),
    body,
    ...xs,
];

const ATTRIB_ALIASES = {
    alpha: "opacity",
    dash: "stroke-dasharray",
    dashOffset: "stroke-dashoffset",
    lineCap: "stroke-linecap",
    lineJoin: "stroke-linejoin",
    miterLimit: "stroke-miterlimit",
    weight: "stroke-width",
};
const TEXT_ALIGN = {
    left: "start",
    right: "end",
    center: "middle",
    start: "start",
    end: "end",
};
const BASE_LINE = {
    top: "text-top",
    bottom: "text-bottom",
};
/**
 * Takes a normalized hiccup tree of {@link @thi.ng/geom# | @thi.ng/geom} or
 * {@link @thi.ng/hdom-canvas# | @thi.ng/hdom-canvas} shape definitions and recursively
 * converts it into an hiccup flavor which is compatible for SVG
 * serialization. This conversion also involves translation & reorg of
 * various attributes. Returns new tree. The original remains untouched,
 * as will any unrecognized tree/shape nodes.
 *
 * @param tree - shape tree
 */
const convertTree = (tree) => {
    if (tree == null)
        return null;
    if (implementsFunction(tree, "toHiccup")) {
        return convertTree(tree.toHiccup());
    }
    const type = tree[0];
    if (isArray(type)) {
        return tree.map(convertTree);
    }
    let attribs = convertAttribs(tree[1]);
    switch (tree[0]) {
        case "svg":
        case "defs":
        case "a":
        case "g": {
            const res = [type, fattribs(attribs)];
            for (let i = 2, n = tree.length; i < n; i++) {
                const c = convertTree(tree[i]);
                c != null && res.push(c);
            }
            return res;
        }
        case "linearGradient":
            return linearGradient(attribs.id, attribs.from, attribs.to, tree[2], {
                gradientUnits: attribs.gradientUnits || "userSpaceOnUse",
                gradientTransform: attribs.gradientTransform,
            });
        case "radialGradient":
            return radialGradient(attribs.id, attribs.from, attribs.to, attribs.r1, attribs.r2, tree[2], {
                gradientUnits: attribs.gradientUnits || "userSpaceOnUse",
                gradientTransform: attribs.gradientTransform,
            });
        case "circle":
            return circle(tree[2], tree[3], attribs, ...tree.slice(4));
        case "ellipse":
            return ellipse(tree[2], tree[3][0], tree[3][1], attribs, ...tree.slice(4));
        case "rect": {
            const r = tree[5] || 0;
            return roundedRect(tree[2], tree[3], tree[4], r, r, attribs, ...tree.slice(6));
        }
        case "line":
            return line(tree[2], tree[3], attribs, ...tree.slice(4));
        case "hline":
            return hline(tree[2], attribs);
        case "vline":
            return vline(tree[2], attribs);
        case "polyline":
            return polyline(tree[2], attribs, ...tree.slice(3));
        case "polygon":
            return polygon(tree[2], attribs, ...tree.slice(3));
        case "path":
            return path(tree[2], attribs, ...tree.slice(3));
        case "text":
            return text(tree[2], tree[3], attribs, ...tree.slice(4));
        case "img":
            return image(tree[3], tree[2].src, attribs, ...tree.slice(4));
        case "points":
            return points(tree[2], attribs.shape, attribs.size, attribs, ...tree.slice(3));
        case "packedPoints":
            return packedPoints(tree[2], attribs.shape, attribs.size, attribs, ...tree.slice(3));
        default:
            return tree;
    }
};
const convertAttribs = (attribs) => {
    const res = {};
    if (!attribs)
        return res;
    // convertTransforms(res, attribs);
    for (let id in attribs) {
        const v = attribs[id];
        const aid = ATTRIB_ALIASES[id];
        if (aid) {
            res[aid] = v;
        }
        else {
            convertAttrib(res, id, v);
        }
    }
    return res;
};
const convertAttrib = (res, id, v) => {
    switch (id) {
        case "font": {
            const i = v.indexOf(" ");
            res["font-size"] = v.substr(0, i);
            res["font-family"] = v.substr(i + 1);
            break;
        }
        case "align":
            res["text-anchor"] = TEXT_ALIGN[v];
            break;
        case "baseline":
            res["dominant-baseline"] = BASE_LINE[v] || v;
            break;
        // case "filter":
        // TODO needs to be translated into <filter> def first
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/filter
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter
        // break;
        default:
            res[id] = v;
    }
};

export { convertTree };

import { isNumber } from '@thi.ng/checks/is-number';
import { isString } from '@thi.ng/checks/is-string';
import '@thi.ng/checks/is-array';
import { assert } from '@thi.ng/errors/assert';
import { unsupported } from '@thi.ng/errors/unsupported';
import { clamp01 } from '@thi.ng/math/interval';
import { fract } from '@thi.ng/math/prec';
import { float } from '@thi.ng/strings/float';
import { percent } from '@thi.ng/strings/percent';
import { setC4 } from '@thi.ng/vectors/setc';
import { U24 } from '@thi.ng/strings/radix';
import { swapLane13 } from '@thi.ng/binary/swizzle';
import '@thi.ng/math/angle';
import { TAU } from '@thi.ng/math/api';
import { dotS3 } from '@thi.ng/vectors/dots';

const CONVERSIONS = {};
const convert = (res, src, destMode, srcMode) => {
    const spec = CONVERSIONS[destMode];
    assert(!!spec, `no conversions available for ${destMode}`);
    let $convert = spec[srcMode];
    return $convert
        ? $convert(res, src)
        : CONVERSIONS.rgb[srcMode]
            ? spec.rgb(res, CONVERSIONS.rgb[srcMode]([], src))
            : unsupported(`can't convert: ${srcMode} -> ${destMode}`);
};

/**
 * RGB black
 */
const BLACK = Object.freeze([0, 0, 0, 1]);
/**
 * RGB white
 */
const WHITE = Object.freeze([1, 1, 1, 1]);
/**
 * RGB red
 */
const RED = Object.freeze([1, 0, 0, 1]);
/**
 * RGB green
 */
const GREEN = Object.freeze([0, 1, 0, 1]);
/**
 * RGB blue
 */
const BLUE = Object.freeze([0, 0, 1, 1]);
/**
 * RGB cyan
 */
const CYAN = Object.freeze([0, 1, 1, 1]);
/**
 * RGB magenta
 */
const MAGENTA = Object.freeze([1, 0, 1, 1]);
/**
 * RGB yellow
 */
const YELLOW = Object.freeze([1, 1, 0, 1]);
/**
 * XYZ D50 to sRGB conversion matrix
 *
 * @remarks
 * Reference:
 * http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */
const XYZ_RGB_D50 = [
    3.1338561, -0.9787684, 0.0719453, -1.6168667, 1.9161415, -0.2289914,
    -0.4906146, 0.033454, 1.4052427,
];
/**
 * XYZ D65 to sRGB conversion matrix
 *
 * @remarks
 * Reference:
 * http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */
const XYZ_RGB_D65 = [
    3.2404542, -0.969266, 0.0556434, -1.5371385, 1.8760108, -0.2040259,
    -0.4985314, 0.041556, 1.0572252,
];
/**
 * CIE Standard Illuminant D50
 */
const D50 = [0.96422, 1, 0.82521];
/**
 * CIE Standard Illuminant D65
 *
 * Reference:
 * https://en.wikipedia.org/wiki/Illuminant_D65
 */
const D65 = [0.95047, 1, 1.08883];
/**
 * Float value formatter
 *
 * @internal
 */
let FF = float(3);
/**
 * Percentage value formatter
 *
 * @internal
 */
let PC = percent(3);
const INV8BIT = 1 / 0xff;

/** @internal */
const __ensureAlpha = (x, def = 1) => x != undefined ? clamp01(x) : def;

const hslCss = (src) => {
    const h = FF(fract(src[0]) * 360);
    const s = PC(clamp01(src[1]));
    const l = PC(clamp01(src[2]));
    const a = __ensureAlpha(src[3]);
    // TODO update to new syntax once CSS Color L4 is more widely supported
    // https://www.w3.org/TR/css-color-4/#serializing-lab-lch
    // https://test.csswg.org/harness/results/css-color-4_dev/grouped/ (test reports)
    // return `hsl(${h} ${s} ${l}` + (a < 1 ? `/${FF(a)})` : ")");
    return a < 1 ? `hsla(${h},${s},${l},${FF(a)})` : `hsl(${h},${s},${l})`;
};

/**
 * Similar to {@link clamp}, but calls `ensureHue` to fold (instead of
 * clamping) the hue into [0,1] interval.
 *
 * @param out - result
 * @param src - source color
 * @param alpha - alpha value
 */
const clampH = (out, src, alpha = 1) => setC4(out || src, fract(src[0]), clamp01(src[1]), clamp01(src[2]), __ensureAlpha(src[3], alpha));

const hsvHsl = (out, src) => {
    out = clampH(out || src, src);
    const s = out[1];
    const v = out[2];
    const l = ((2 - s) * v) / 2;
    out[2] = l;
    out[1] = l && l < 1 ? (s * v) / (l < 0.5 ? l * 2 : 2 - l * 2) : s;
    return out;
};

const hsvCss = (src) => hslCss(hsvHsl([], src));

const intArgb32Css = (src) => {
    const a = src >>> 24;
    return a < 255
        ? `rgba(${(src >> 16) & 0xff},${(src >> 8) & 0xff},${src & 0xff},${FF(a * INV8BIT)})`
        : `#${U24(src & 0xffffff)}`;
};

/**
 * Alias for {@link intArgbAbgr}.
 */
const intAbgr32Argb32 = swapLane13;

const lchLab = (out, src) => {
    let { 1: c, 2: h } = src;
    h *= TAU;
    const a = __ensureAlpha(src[3]);
    return c > 0
        ? setC4(out || src, src[0], Math.cos(h) * c, Math.sin(h) * c, a)
        : setC4(out || src, src[0], 0, 0, a);
};

const transform = (x) => {
    const y = x ** 3;
    return y > 0.008856 ? y : (x - 16 / 116) / 7.787;
};
/**
 * Converts Lab to XYZ using provided white point (default: {@link D50}). Also
 * see {@link labXyzD65}.
 *
 * @param out
 * @param src
 * @param white
 */
const labXyz = (out, src, white = D50) => {
    const y = (src[0] + 0.16) / 1.16;
    return setC4(out || src, transform(src[1] / 5.0 + y) * white[0], transform(y) * white[1], transform(y - src[2] / 2.0) * white[2], __ensureAlpha(src[3]));
};
/**
 * Same as {@link labXyz}, but using hardcoded {@link D65} white point.
 *
 * @param out
 * @param src
 */
const labXyzD65 = (out, src) => labXyz(out, src, D65);

/** @internal */
const __mulV33 = (out, mat, src, clampOut = false) => {
    const x = dotS3(mat, src, 0, 0, 3);
    const y = dotS3(mat, src, 1, 0, 3);
    const z = dotS3(mat, src, 2, 0, 3);
    const a = __ensureAlpha(src[3]);
    return clampOut
        ? setC4(out || src, clamp01(x), clamp01(y), clamp01(z), a)
        : setC4(out || src, x, y, z, a);
};

/**
 * Converts CIE XYZ to RGB using provided transformation/whitepoint matrix
 * (default: {@link XYZ_RGB_D50}).
 *
 * {@link https://en.wikipedia.org/wiki/CIE_1931_color_space}
 *
 * @param out - result
 * @param src - source color
 */
const xyzRgb = (out, src, mat = XYZ_RGB_D50) => __mulV33(out, mat, src);
/**
 * Same as {@link xyzRgb}, but hard coded to use {@link D65} white point (via
 * {@link XYZ_RGB_D65} matrix).
 *
 * @param out
 * @param src
 */
const xyzRgbD65 = (out, src) => xyzRgb(out, src, XYZ_RGB_D65);

/**
 * Converts Lab to linear RGB (via XYZ) using {@link D50} white point.
 *
 * @param out
 * @param src
 */
const labRgb = (out, src) => xyzRgb(null, labXyz(out, src));
/**
 * Same as {@link labRgb}, but using {@link D65} white point.
 *
 * @param out
 * @param src
 */
const labRgbD65 = (out, src) => xyzRgbD65(null, labXyzD65(out, src));

/**
 * Maps a single linear RGB channel value to sRGB.
 *
 * {@link https://en.wikipedia.org/wiki/SRGB}
 *
 * @param x - channel value
 */
const linearSrgb = (x) => x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

/**
 * Converts linear RGB to sRGB.
 *
 * @param out - result
 * @param src - source color
 */
const rgbSrgb = (out, src) => setC4(out || src, linearSrgb(src[0]), linearSrgb(src[1]), linearSrgb(src[2]), __ensureAlpha(src[3]));

/** @internal */
const __scale8bit = (x, shift = 0) => ((x < 0 ? 0 : x > 1 ? 1 : x) * 0xff + 0.5) << shift;

const srgbCss = (src) => {
    const r = __scale8bit(src[0]);
    const g = __scale8bit(src[1]);
    const b = __scale8bit(src[2]);
    const a = __ensureAlpha(src[3]);
    // TODO update to `rgb(${r} ${g} ${b}/${FF(a)})` (CSS L4 syntax)
    return a < 1
        ? `rgba(${r},${g},${b},${FF(a)})`
        : `#${U24((r << 16) | (g << 8) | b)}`;
};

const rgbCss = (src) => srgbCss(rgbSrgb([], src));

/** @internal */
const CSS_CONVERSIONS = {
    abgr32: (x) => intArgb32Css(intAbgr32Argb32(x[0])),
    argb32: (x) => intArgb32Css(x[0]),
    hsl: hslCss,
    hsv: hsvCss,
    // TODO temporarily disabled until CSS L4 is officially supported in browsers
    // currently serializing as sRGB CSS
    // lab50: labCss,
    // lab65: (x) => labCss(labLabD65_50([], x)),
    // lch: lchCss,
    lab50: (src) => srgbCss(rgbSrgb(null, labRgb([], src))),
    lab65: (src) => srgbCss(rgbSrgb(null, labRgbD65([], src))),
    lch: (src) => srgbCss(rgbSrgb(null, labRgb(null, lchLab([], src)))),
    rgb: rgbCss,
    srgb: srgbCss,
};
/**
 * Takes a color in one of the following formats and tries to convert it
 * to a CSS string:
 *
 * - any {@link TypedColor} instance
 * - raw sRGB(A) vector
 * - number (packed 0xaarrggbb int, MUST provide alpha channel)
 * - string (passthrough)
 *
 * @param col - source color
 */
const css = (src) => {
    let asCss;
    return isString(src)
        ? src
        : isNumber(src)
            ? intArgb32Css(src)
            : src.mode
                ? (asCss = CSS_CONVERSIONS[src.mode])
                    ? asCss(src)
                    : CSS_CONVERSIONS.rgb(convert([], src, "rgb", src.mode))
                : srgbCss(src);
};

export { css };

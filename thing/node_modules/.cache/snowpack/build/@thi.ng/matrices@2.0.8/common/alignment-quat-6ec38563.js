import { cross3 } from '@thi.ng/vectors/cross';
import { dot3 } from '@thi.ng/vectors/dot';
import { mag } from '@thi.ng/vectors/mag';
import { normalize } from '@thi.ng/vectors/normalize';
import { EPS } from '@thi.ng/math/api';

/**
 * Computes a quaternion representing the rotation `theta` around
 * `axis`.
 *
 * @param axis -
 * @param theta -
 */
const quatFromAxisAngle = (axis, theta) => {
    theta *= 0.5;
    return normalize([0, 0, 0, Math.cos(theta)], axis, Math.sin(theta));
};
/**
 * Decomposes quaternion into `[axis, theta]` tuple.
 *
 * @param quat -
 */
const quatToAxisAngle = (quat) => {
    const n = normalize([], quat);
    const w = n[3];
    const m = Math.sqrt(1 - w * w);
    const theta = 2 * Math.acos(w);
    return m > EPS
        ? [[n[0] / m, n[1] / m, n[2] / m], theta]
        : [[n[0], n[1], n[2]], theta];
};

/**
 * Returns quaternion describing the rotation from direction vector
 * `from` -> `to`. If `normalize` is true (default), first normalizes
 * the vectors (not modifying original).
 *
 * @param from -
 * @param to -
 * @param normalize -
 */
const alignmentQuat = (from, to, normalize$1 = true) => {
    if (normalize$1) {
        from = normalize([], from);
        to = normalize([], to);
    }
    const axis = cross3([], from, to);
    return quatFromAxisAngle(axis, Math.atan2(mag(axis), dot3(from, to)));
};

export { alignmentQuat as a, quatToAxisAngle as b, quatFromAxisAngle as q };
